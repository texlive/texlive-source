	Determine lib_dir and modules_dir in the xindy perl script.

	Also implement symlinks, e.g., in /usr/local/bin/ for
	standalone version.

	Drop xindy.v2 backwards compatibility.

	Invoke either 'xindy.run' or 'clisp'.

	Verify existence of input files.

diff -ur -x Makefile.in -x autom4te.cache xindy.orig/user-commands/xindy.in xindy/user-commands/xindy.in
--- xindy.orig/user-commands/xindy.in	2009-12-03 01:27:06.000000000 +0100
+++ xindy/user-commands/xindy.in	2009-12-12 17:57:03.000000000 +0100
@@ -286,11 +286,47 @@
 # Determine environment. Where is our library directory, and our modules?
 
 use File::Basename;
+use Cwd;
+our ($isW32, $clisp);
 our ($cmd_dir, $cmd, $lib_dir, $modules_dir);
 BEGIN {
-    $cmd_dir = dirname($0);
+    $isW32 = ($^O =~ /^MSWin/i) ? 1 : 0;
+    $clisp = ($isW32 || $^O eq "cygwin") ? 'clisp.exe' : 'clisp';
+
+    my $r0 = Cwd::realpath($0);
+    $cmd_dir = dirname($r0);
     $cmd = basename($0);
 
+    if (basename($r0) =~ /\.pl$/) { # TL2010
+
+	# modules directory
+	$modules_dir = Cwd::realpath("$cmd_dir/../../xindy/modules");
+	die "$cmd: Cannot locate xindy modules directory"  unless -d $modules_dir;
+
+	if ($isW32) {
+	    $cmd_dir = "$cmd_dir/../../../bin/win32";
+	} else {
+	    die "$cmd: not a symlink as required for TeX Live"  unless -l $0;
+	    # Follow symlinks and determine $cmd_dir such that
+	    # $cmd_dir/xindy -> $r0 = XINDY_SCRIPTDIR/xindy.pl
+	    $r0 = $0;
+	    while (-l $r0) {
+		$cmd_dir = dirname($r0);
+		$r0 = readlink($r0);
+		$r0 = "$cmd_dir/$r0"  unless $r0 =~ m,^[\\/],; # relative link
+	    }
+	}
+
+	# library directory
+        $lib_dir = $cmd_dir;
+
+	# clisp runtime
+	my $xindy_run = ($isW32 || $^O eq "cygwin")
+		      ? "$lib_dir/xindy-lisp.exe" : "$lib_dir/xindy.run";
+	$clisp = $xindy_run  if -e $xindy_run;
+
+    } else { # !TL2010
+
     # library directory
     if ( $ENV{XINDY_LIBDIR} ) {
 	$lib_dir = $ENV{XINDY_LIBDIR};
@@ -316,6 +352,8 @@
     } else {
 	die "$cmd: Cannot locate xindy modules directory";
     }
+
+    } # !TL2010
 }
 
 
@@ -324,14 +362,10 @@
 use Getopt::Long qw(:config bundling);
 use File::Temp qw(tempfile tmpnam);
 use File::Spec;
+use POSIX qw(uname);
 
 
 # Check arguments, store them in proper variables.
-#
-# Do also something for backward compatibility: Check if this is an
-# old-style call. If it is, we have two arguments at the end, and the
-# second-to-last has the extension ".xdy". Then, call the old driver
-# script with the original arguments...
 
 sub usage ( ;$ )
 {
@@ -368,17 +402,21 @@
      $outfile, $logfile, $language, @codepages, @modules, $input_markup,
      $interactive, $mem_file);
 $input_markup = 'latex';
+
 $mem_file = "$lib_dir/xindy.mem";
+if ($^O eq 'darwin' && ! -e $mem_file) { # support universal binary on mac
+    my @uname = POSIX::uname();
+    if ($uname[4] eq 'Power Macintosh') {
+	$mem_file = "$lib_dir/xindy-ppc.mem";
+    } else {
+	$mem_file = "$lib_dir/xindy-i386.mem";
+    }
+}
+die "$cmd: Cannot locate $mem_file"  unless -e $mem_file;
 
 my @orig_argv = @ARGV;
 parse_options();
 
-if ( @ARGV == 2 ) {
-    if ( $ARGV[0] =~ /\.xdy$/ ) {
-	exec "$cmd_dir/xindy.v2", @orig_argv;
-    }
-}
-
 
 # This script creates temporary files. Whenever a file is created, its
 # name is added to @temp_files. In an END handler, the temporary files
@@ -400,6 +438,7 @@
 
 our $raw_index = File::Spec->devnull;
 unless ( $interactive ) {
+    for my $f (@ARGV) { die "$cmd: input file $f does not exist"  unless -f $f }
     $raw_index = create_raw_index();	# processes @ARGV
     my $filter_cmd = '';
     if ( $input_markup eq 'latex' ) {
@@ -674,7 +713,7 @@
 sub call_xindy ( $$ ) {
     my ($mem_file, $xindy_exp) = @_;
 
-    my @command = ('clisp', '-M', $mem_file, '-E', 'iso-8859-1');
+    my @command = ($clisp, '-M', $mem_file, '-E', 'iso-8859-1');
     if ( $interactive ) {
 	print "Proposed xindy expression:\n\n$xindy_exp\n"  unless $quiet;
     } else {
@@ -711,7 +750,9 @@
 sub output_xindy_release () {
     my $version = 'unknown';
     my $version_file;
-    if ( -f "$cmd_dir/../VERSION" ) {
+    if ( -f "$modules_dir/../VERSION" ) {
+	$version_file = "$modules_dir/../VERSION";
+    } elsif ( -f "$cmd_dir/../VERSION" ) {
 	$version_file = "$cmd_dir/../VERSION";
     } elsif ( -f "$lib_dir/VERSION" ) {
 	$version_file = "$lib_dir/VERSION";

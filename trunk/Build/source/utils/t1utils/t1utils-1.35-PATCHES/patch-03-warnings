	Avoid compiler warnings:
	ANSI C function definitions.
	Declare various (param and other) strings as const.

diff -ur t1utils-1.35.orig/clp.c t1utils-1.35/clp.c
--- t1utils-1.35.orig/clp.c	2010-05-10 10:06:31.000000000 +0200
+++ t1utils-1.35/clp.c	2010-05-10 10:36:50.091602641 +0200
@@ -275,7 +275,7 @@
 }
 
 static int
-decode_utf8(const char *s, char **cp)
+decode_utf8(const char *s, const char **cp)
 {
     int c;
     if ((unsigned char) *s <= 0x7F)		/* 1 byte:  0x000000-0x00007F */
@@ -319,14 +319,14 @@
 	    /* nothing */;
     }
     if (cp)
-	*cp = (char *) s;
+	*cp = s;
     return c;
 }
 
 static int
 utf8_charlen(const char *s)
 {
-    char *sout;
+    const char *sout;
     (void) decode_utf8(s, &sout);
     return sout - s;
 }
@@ -364,7 +364,7 @@
     if ((cli->long1pos || cli->long1neg) && io->ilong) {
 	const char *name = o->long_name + io->ilongoff;
 	if (cli->utf8) {
-	    int c = decode_utf8(name, (char **) &name);
+	    int c = decode_utf8(name, &name);
 	    if (!*name && c && c != U_REPLACEMENT)
 		return c;
 	} else if (name[0] && !name[1])
@@ -1068,22 +1068,28 @@
 static int
 parse_int(Clp_Parser *clp, const char *arg, int complain, void *user_data)
 {
-    char *val;
+    const char *val;
+    char *temp;
     if (*arg == 0 || isspace((unsigned char) *arg)
 	|| (user_data != 0 && *arg == '-'))
-	val = (char *) arg;
+	val = arg;
     else if (user_data != 0) {	/* unsigned */
 #if HAVE_STRTOUL
-	clp->val.u = strtoul(arg, &val, 0);
+	clp->val.u = strtoul(arg, &temp, 0);
+	val = temp;
 #else
 	/* don't bother really trying to do it right */
 	if (arg[0] == '-')
-	    val = (char *) arg;
-	else
-	    clp->val.u = strtol(arg, &val, 0);
+	    val = arg;
+	else {
+	    clp->val.u = strtol(arg, &temp, 0);
+	    val = temp;
+	}
 #endif
-    } else
-	clp->val.i = strtol(arg, &val, 0);
+    } else {
+	clp->val.i = strtol(arg, &temp, 0);
+	val = temp;
+    }
     if (*arg != 0 && *val == 0)
 	return 1;
     else if (complain) {
@@ -1098,12 +1104,15 @@
 static int
 parse_double(Clp_Parser *clp, const char *arg, int complain, void *user_data)
 {
-    char *val;
+    const char *val;
+    char *temp;
     (void)user_data;
     if (*arg == 0 || isspace((unsigned char) *arg))
-	val = (char *) arg;
-    else
-	clp->val.d = strtod(arg, &val);
+	val = arg;
+    else {
+	clp->val.d = strtod(arg, &temp);
+	val = temp;
+    }
     if (*arg != 0 && *val == 0)
 	return 1;
     else if (complain)
@@ -1516,7 +1525,7 @@
 {
     int c;
     if (clp->internal->utf8) {
-	char *s;
+	const char *s;
 	c = decode_utf8(text, &s);
 	*ocharskip = s - text;
     } else {
diff -ur t1utils-1.35.orig/t1ascii.c t1utils-1.35/t1ascii.c
--- t1utils-1.35.orig/t1ascii.c	2010-05-10 09:55:47.000000000 +0200
+++ t1utils-1.35/t1ascii.c	2010-05-10 10:08:33.942078828 +0200
@@ -172,7 +172,7 @@
 }
 
 static void
-pfa_output_end()
+pfa_output_end(void)
 {
 }
 
diff -ur t1utils-1.35.orig/t1asm.c t1utils-1.35/t1asm.c
--- t1utils-1.35.orig/t1asm.c	2010-05-10 09:55:47.000000000 +0200
+++ t1utils-1.35/t1asm.c	2010-05-10 10:08:33.942078828 +0200
@@ -266,7 +266,7 @@
    charstring. We use the heuristic that it should start with `/' (a name) or
    `dup' (a subroutine). Previous heuristic caused killa bad output. */
 
-static int check_line_charstring()
+static int check_line_charstring(void)
 {
   char *p = line;
   while (isspace(*p))
@@ -280,7 +280,7 @@
    the newline is put into line[]. When terminated by '{', the '{' is not put
    into line[], and the flag start_charstring is set to 1. */
 
-static void t1utils_getline()
+static void t1utils_getline(void)
 {
   int c;
   char *p = line;
@@ -367,7 +367,7 @@
 /* This function initializes charstring encryption.  Note that this is called
    at the beginning of every charstring. */
 
-static void charstring_start()
+static void charstring_start(void)
 {
   int i;
 
@@ -390,7 +390,7 @@
 /* This function outputs buffered, encrypted charstring data through possible
    eexec encryption. */
 
-static void charstring_end()
+static void charstring_end(void)
 {
   byte *bp;
 
@@ -433,7 +433,7 @@
 
 /* This function returns one charstring token. It ignores comments. */
 
-static void get_charstring_token()
+static void get_charstring_token(void)
 {
   int c = getc(ifp);
   while (isspace(c))
@@ -466,7 +466,7 @@
 /* This function parses an entire charstring into integers and commands,
    outputting bytes through the charstring buffer. */
 
-static void parse_charstring()
+static void parse_charstring(void)
 {
   struct command *cp;
 
diff -ur t1utils-1.35.orig/t1binary.c t1utils-1.35/t1binary.c
--- t1utils-1.35.orig/t1binary.c	2010-05-10 09:55:47.000000000 +0200
+++ t1utils-1.35/t1binary.c	2010-05-10 10:08:33.942078828 +0200
@@ -85,7 +85,7 @@
 }
 
 static void
-pfb_output_end()
+pfb_output_end(void)
 {
   pfb_writer_end(&w);
 }
diff -ur t1utils-1.35.orig/t1disasm.c t1utils-1.35/t1disasm.c
--- t1utils-1.35.orig/t1disasm.c	2010-05-10 09:55:47.000000000 +0200
+++ t1utils-1.35/t1disasm.c	2010-05-10 10:08:33.942078828 +0200
@@ -332,11 +332,11 @@
 /* 23.Feb.2004 - use 'memstr', not strstr, because the strings input to
    eexec_line aren't null terminated! Reported by Werner Lemberg. */
 
-static const unsigned char *
-oog_memstr(const unsigned char *line, int line_len, const char *pattern, int pattern_len)
+static unsigned char *
+oog_memstr(unsigned char *line, int line_len, const char *pattern, int pattern_len)
 {
-    const unsigned char *try;
-    const unsigned char *last = line + line_len - pattern_len + 1;
+    unsigned char *try;
+    unsigned char *last = line + line_len - pattern_len + 1;
     while (line < last
 	   && (try = memchr(line, (unsigned char)*pattern, last - line))) {
 	if (memcmp(try, pattern, pattern_len) == 0)
@@ -432,7 +432,7 @@
        badly: a charstring definition follows "/Charstrings ... begin", ON THE
        SAME LINE. */
     {
-	const char *CharStrings = (const char *)
+	char *CharStrings = (char *)
 	    oog_memstr(line, line_len, "/CharStrings ", 13);
 	int crap, n;
 	char should_be_slash = 0;
@@ -595,7 +595,7 @@
 }
 
 static void
-disasm_output_end()
+disasm_output_end(void)
 {
     /* take care of leftover saved data */
     static char crap[1] = "";

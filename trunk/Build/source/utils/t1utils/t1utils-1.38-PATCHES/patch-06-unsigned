	Avoid undefined behaviour when char is signed.

diff -ur t1utils-1.38.orig/t1asm.c t1utils-1.38/t1asm.c
--- t1utils-1.38.orig/t1asm.c	2013-09-29 15:23:22.000000000 +0200
+++ t1utils-1.38/t1asm.c	2014-06-19 13:08:40.000000000 +0200
@@ -273,7 +273,7 @@
 static int check_line_charstring(void)
 {
   char *p = line;
-  while (isspace(*p))
+  while (isspace((unsigned char)*p))
     p++;
   return (*p == '/' || (p[0] == 'd' && p[1] == 'u' && p[2] == 'p'));
 }
@@ -359,8 +359,8 @@
 
 static int is_integer(char *string)
 {
-  if (isdigit(string[0]) || string[0] == '-' || string[0] == '+') {
-    while (*++string && isdigit(*string))
+  if (isdigit((unsigned char)string[0]) || string[0] == '-' || string[0] == '+') {
+    while (*++string && isdigit((unsigned char)*string))
       ;                                           /* deliberately empty */
     if (!*string)
       return 1;
@@ -738,11 +738,11 @@
     t1utils_getline();
 
     if (!ever_active) {
-      if (strncmp(line, "currentfile eexec", 17) == 0 && isspace(line[17])) {
+      if (strncmp(line, "currentfile eexec", 17) == 0 && isspace((unsigned char)line[17])) {
 	/* Allow arbitrary whitespace after "currentfile eexec".
 	   Thanks to Tom Kacvinsky <tjk@ams.org> for reporting this.
 	   Note: strlen("currentfile eexec") == 17. */
-	for (p = line + 18; isspace(*p); p++)
+	for (p = line + 18; isspace((unsigned char)*p); p++)
 	  ;
 	eexec_start(p);
 	continue;
@@ -756,7 +756,7 @@
 	if (q) {
 	  r = cs_start;
 	  ++q;
-	  while (!isspace(*q) && *q != '{')
+	  while (!isspace((unsigned char)*q) && *q != '{')
 	    *r++ = *q++;
 	  *r = '\0';
 	}
@@ -765,9 +765,9 @@
     }
 
     if (!active) {
-      if ((p = strstr(line, "/Subrs")) && isdigit(p[7]))
+      if ((p = strstr(line, "/Subrs")) && isdigit((unsigned char)p[7]))
 	ever_active = active = 1;
-      else if ((p = strstr(line, "/CharStrings")) && isdigit(p[13]))
+      else if ((p = strstr(line, "/CharStrings")) && isdigit((unsigned char)p[13]))
 	ever_active = active = 1;
     }
     if ((p = strstr(line, "currentfile closefile"))) {
@@ -776,7 +776,7 @@
       /* 1/3/2002 -- happy new year! -- Luc Devroye reports a failure with
          some printers when `currentfile closefile' is followed by space */
       p += sizeof("currentfile closefile") - 1;
-      for (q = p; isspace(*q) && *q != '\n'; q++)
+      for (q = p; isspace((unsigned char)*q) && *q != '\n'; q++)
 	/* nada */;
       if (q == p && !*q)
 	error("warning: `currentfile closefile' line too long");
diff -ur t1utils-1.38.orig/t1disasm.c t1utils-1.38/t1disasm.c
--- t1utils-1.38.orig/t1disasm.c	2013-10-03 14:02:25.000000000 +0200
+++ t1utils-1.38/t1disasm.c	2014-06-19 13:08:40.000000000 +0200
@@ -100,7 +100,7 @@
   char *p = strstr(line, "/lenIV ");
 
   /* Allow lenIV to be negative. Thanks to Tom Kacvinsky <tjk@ams.org> */
-  if (p && (isdigit(p[7]) || p[7] == '+' || p[7] == '-')) {
+  if (p && (isdigit((unsigned char)p[7]) || p[7] == '+' || p[7] == '-')) {
     lenIV = atoi(p + 7);
   }
 }
@@ -120,7 +120,7 @@
     if (q) {
       r = cs_start;
       ++q;
-      while (!isspace(*q) && *q != '{')
+      while (!isspace((unsigned char)*q) && *q != '{')
 	*r++ = *q++;
       *r = '\0';
     }
diff -ur t1utils-1.38.orig/t1lib.c t1utils-1.38/t1lib.c
--- t1utils-1.38.orig/t1lib.c	2013-09-29 15:23:22.000000000 +0200
+++ t1utils-1.38/t1lib.c	2014-06-19 13:08:40.000000000 +0200
@@ -59,7 +59,7 @@
   char *start = s;
   char *t = s;
   for (; *s; s++) {
-    if (isspace(*s))
+    if (isspace((unsigned char)*s))
       continue;
     if (c1) {
       *t++ = (hexval(c1) << 4) + hexval(*s);
@@ -136,10 +136,10 @@
 
 	/* now that we have the line, handle it */
 	if (blocktyp == PFA_ASCII) {
-	    if (strncmp(line, "currentfile eexec", 17) == 0 && isspace(line[17])) {
+	    if (strncmp(line, "currentfile eexec", 17) == 0 && isspace((unsigned char)line[17])) {
 		char saved_p;
 		/* assert(line == buffer); */
-		for (line += 18; isspace(*line); line++)
+		for (line += 18; isspace((unsigned char)*line); line++)
 		    /* nada */;
 		saved_p = *line;
 		*line = 0;
@@ -158,12 +158,12 @@
 	if (blocktyp == PFA_EEXEC_TEST) {
 	    /* 8.Feb.2004: fix bug if first character in a binary eexec block
 	       is 0, reported by Werner Lemberg */
-	    for (; line < last && isspace(*line); line++)
+	    for (; line < last && isspace((unsigned char)*line); line++)
 		/* nada */;
 	    if (line == last)
 		continue;
-	    else if (last >= line + 4 && isxdigit(line[0]) && isxdigit(line[1])
-		     && isxdigit(line[2]) && isxdigit(line[3]))
+	    else if (last >= line + 4 && isxdigit((unsigned char)line[0]) && isxdigit((unsigned char)line[1])
+		     && isxdigit((unsigned char)line[2]) && isxdigit((unsigned char)line[3]))
 		blocktyp = PFA_HEX;
 	    else
 		blocktyp = PFA_BINARY;
diff -ur t1utils-1.38.orig/t1mac.c t1utils-1.38/t1mac.c
--- t1utils-1.38.orig/t1mac.c	2013-09-29 15:23:22.000000000 +0200
+++ t1utils-1.38/t1mac.c	2014-06-19 13:08:40.000000000 +0200
@@ -370,10 +370,10 @@
     s[len-1] = '\r';
   t1mac_output_data((byte *)s, len);
   if (strncmp(s, "/FontName", 9) == 0) {
-    for (s += 9; isspace(*s); s++) ;
+    for (s += 9; isspace((unsigned char)*s); s++) ;
     if (*s == '/') {
       const char *t = ++s;
-      while (*t && !isspace(*t)) t++;
+      while (*t && !isspace((unsigned char)*t)) t++;
       free(font_name);
       font_name = (char *)malloc(t - s + 1);
       memcpy(font_name, s, t - s);
@@ -992,11 +992,11 @@
     int part = 0, len = 0;
     char *x, *s;
     for (x = s = font_name; *s; s++)
-      if (isupper(*s) || isdigit(*s)) {
+      if (isupper((unsigned char)*s) || isdigit((unsigned char)*s)) {
 	*x++ = *s;
 	part++;
 	len = 1;
-      } else if (islower(*s)) {
+      } else if (islower((unsigned char)*s)) {
 	if (len < (part <= 1 ? 5 : 3))
 	  *x++ = *s;
 	len++;

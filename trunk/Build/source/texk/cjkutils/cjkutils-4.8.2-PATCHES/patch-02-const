diff -ur cjkutils-4.8.2.orig/hbf2gf/hbf.c cjkutils-4.8.2/hbf2gf/hbf.c
--- cjkutils-4.8.2.orig/hbf2gf/hbf.c	2009-10-01 00:00:00.000000000 +0200
+++ cjkutils-4.8.2/hbf2gf/hbf.c	2009-10-01 00:04:37.000000000 +0200
@@ -1462,18 +1462,18 @@
 		 byte *startp, byte *finishp)
 {
 	HBF_STRUCT	*hbf;
-	B2_RANGE	*b2r;
+	const B2_RANGE	*b2r;
 
 	hbf = (HBF_STRUCT *)hbfFile;
 	if (b2r_pointer == NULL)
 		b2r = hbf->byte_2_range;
 	else
-		b2r = ((B2_RANGE *)b2r_pointer)->b2r_next;
+		b2r = ((const B2_RANGE *)b2r_pointer)->b2r_next;
 	if(b2r == NULL)
 		return NULL;
 	*startp = b2r->b2r_start;
 	*finishp = b2r->b2r_finish;
-	return (void *)b2r;
+	return (const void *)b2r;
 }
 
 const void *
@@ -1481,16 +1481,16 @@
 		HBF_CHAR *startp, HBF_CHAR *finishp)
 {
 	HBF_STRUCT	*hbf;
-	CODE_RANGE	*cp;
+	const CODE_RANGE	*cp;
 
 	hbf = (HBF_STRUCT *)hbfFile;
 	if (code_pointer == NULL)
 		cp = hbf->code_range;
 	else
-		cp = ((CODE_RANGE *)code_pointer)->code_next;
+		cp = ((const CODE_RANGE *)code_pointer)->code_next;
 	if(cp == NULL)
 		return NULL;
 	*startp = cp->code_start;
 	*finishp = cp->code_finish;
-	return (void *)cp;
+	return (const void *)cp;
 }
diff -ur cjkutils-4.8.2.orig/hbf2gf/hbf2gf.w cjkutils-4.8.2/hbf2gf/hbf2gf.w
--- cjkutils-4.8.2.orig/hbf2gf/hbf2gf.w	2009-10-01 00:00:00.000000000 +0200
+++ cjkutils-4.8.2/hbf2gf/hbf2gf.w	2009-10-01 00:04:37.000000000 +0200
@@ -871,7 +871,7 @@
 HBF_CHAR code;
 const unsigned char *bitmap;
             /* a proper input bitmap array will be allocated by the HBF API */
-unsigned char *bP;@#
+const unsigned char *bP;@#
 
 unsigned char out_char[MAX_CHAR_SIZE * MAX_CHAR_SIZE + 1];
                                                  /* the output bitmap array */
@@ -1025,7 +1025,7 @@
     if(b2_codes[code & 0xFF]) /* a valid second byte? */
        {if(pk_files)
            {bitmap = hbfGetBitmap(hbf, code);
-            bP = (unsigned char *)bitmap;
+            bP = bitmap;
                                      /* will be increased by |read_row()| */@#
 
             if(!bitmap)
@@ -1238,7 +1238,7 @@
     if(rotation)
        {bitshift = 7 - (curr_row % 8);
         offset = (input_size_y + 7) / 8;
-        bP = (unsigned char *)bitmap + curr_row / 8;
+        bP = bitmap + curr_row / 8;
         for(col = 0, xP = pixelrow; col < input_size_x; ++col, ++xP)
            {*xP = ((*bP >> bitshift) & 1) == 1 ? PIXEL_MAXVAL : 0;
             bP += offset;
@@ -2305,13 +2305,14 @@
 |Buffer| if existent. |fsearch()| returns~1 on success.
 
 @<Prototypes@>=
-int fsearch(char *);
+int fsearch(const char *);
 
 
 @
 @c
-int fsearch(char *search_string)
+int fsearch(const char *search_string)
    {char *P, p;
+    const char *Q;
     char temp_buffer[STRING_LENGTH + 1];
     char env_name[STRING_LENGTH + 1];
     char *env_p;
@@ -2323,8 +2324,8 @@
     rewind(config); /* we start at offset~0 */@#
 
     do
-       {P = search_string;
-        p = tolower(*P);
+       {Q = search_string;
+        p = tolower(*Q);
         Ch = fgetc(config);
         ch = tolower(Ch);
         while(!(ch == p && old_ch == '\n') && Ch != EOF)
@@ -2336,12 +2337,12 @@
            }@#
 
         for(;;)
-           {if(*(++P) == '\0')
+           {if(*(++Q) == '\0')
                 if((Ch = fgetc(config)) == ' ' || Ch == '\t')
                    /* there must be a space or a tab stop after the keyword */
                     goto success;
             Ch = fgetc(config);
-            if(tolower(Ch) != tolower(*P))
+            if(tolower(Ch) != tolower(*Q))
                 break;
            }
        }
@@ -2443,12 +2444,12 @@
 message.
 
 @<Prototypes@>=
-void config_error(char *);
+void config_error(const char *);
 
 
 @
 @c
-void config_error(char *message)
+void config_error(const char *message)
    {fprintf(stderr, "Couldn't find `%s' entry in configuration file\n",
             message);
     exit(1);
@@ -2501,12 +2502,12 @@
 
 @
 @<Prototypes@>=
-char *TeX_search_version(void);
+const char *TeX_search_version(void);
 
 
 @
 @c
-char *TeX_search_version(void)
+const char *TeX_search_version(void)
    {
 #if defined(HAVE_LIBKPATHSEA)
     return kpathsea_version_string;

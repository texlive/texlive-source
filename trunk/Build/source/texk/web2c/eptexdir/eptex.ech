% eptexdir/eptex.ech: changefile used to build e-pTeX, see eptexdir/eptex-base.ch for details.
% Public domain. Originally written by Peter Breitenlohner <tex-live@tug.org>.

@x e-pTeX: logo
\def\eTeX{$\varepsilon$-\TeX}
@y
\def\eTeX{$\varepsilon$-\TeX}
\def\epTeX{$\varepsilon$-p\TeX}
@z

@x [1.2] l.200 - pTeX:
@d pTeX_version_string=='-p3.1.11' {current p\TeX\ version}
@y
@d  pTeX_version_string=='-p3.1.11-110315' {current \epTeX\ version}
@z

@x e-pTeX: banner
  {printed when p\TeX\ starts}
@y
  {printed when p\TeX\ starts}
@#
@d epTeX_version==pTeX_version_string,eTeX_version_string
@d epTeX_banner=='This is e-pTeX, Version 3.1415926',epTeX_version
@d epTeX_banner_k==epTeX_banner
  {printed when \epTeX\ starts}
@z

@x
@d max_quarterword=255 {largest allowable value in a |quarterword|}
@y
@d max_quarterword=@"FFFF {largest allowable value in a |quarterword|}
@z

@x
@d box_dir(#) == subtype(#) {direction mode of a box}
@d set_box_dir(#) == subtype(#):=set_box_dir_end
@y
@d box_dir(#) == (subtype(#)mod 8) {direction mode of a box}
@d set_box_dir(#) == subtype(#):=(subtype(#)div 8)*8+set_box_dir_end 
@z

@x [26.424] l.8510 - e-pTeX: last node
@d find_effective_tail==find_effective_tail_pTeX
@y
@d find_effective_tail_epTeX(#)== {Ignore final |disp_node| and\slash or \.{\\endM} node}
find_effective_tail_pTeX(#);
if (type(tx)=math_node)and(subtype(tx)=end_M_code) then
  begin r:=head;
  repeat q:=r; r:=link(q); until link(r)=tx;
  if is_char_node(r) then #;
  if (type(r)=disp_node) then
    if is_char_node(q)or(q=head) then #
    else tx:=q
  else tx:=r;
  end
@#
@d find_effective_tail==find_effective_tail_epTeX
@z

@x [26.424] l.8517 - e-pTeX: node types
    if (tail=head)or(mode=0) then cur_val:=-1;
@y
    if (tail=head)or(mode=0)or@|
       ((tail=link(head))and not is_char_node(tail)and(type(tail)=disp_node))
      then cur_val:=-1;
@z

@x [26.424] e-pTeX: node types
      last_node_type_code: if type(tx)<=unset_node then cur_val:=type(tx)+1
        else cur_val:=unset_node+2;
@y
      last_node_type_code: if type(tx)<=unset_node then
          begin if type(tx)=dir_node then tx:=list_ptr(tx);
          cur_val:=type(tx);
          if cur_val<dir_node then cur_val:=cur_val+1
          else if cur_val>disp_node then cur_val:=cur_val-1;
          end
        else cur_val:=unset_node; {\epTeX's |unset_node| is \eTeX's |unset_node+2|}
@z

@x e-pTeX: if primitives - leave room for three e-TeX codes
@d if_tdir_code=if_case_code+1 { `\.{\\iftdir}' }
@y
@d if_tdir_code=if_case_code+4 { `\.{\\iftdir}' }
@z

@x
@d box_lrstat(#) == subtype(#) {direction mode of a box}
@d set_box_lrstat(#) ==  subtype(#):=set_box_lrstat_end
@d set_box_lrstat_end(#) == #
@y
@d box_lrstat(#) == (subtype(#)div 8) {direction mode of a box}
@d set_box_lrstat(#) == subtype(#):=(subtype(#)mod 8)+8*set_box_lrstat_end
@d set_box_lrstat_end(#) == (#)
@z

@x [47.1079] l.20920
@!r:pointer; {running behind |p|}
@!a_dir:eight_bits; {adjust direction}
@!disp,@!pdisp:scaled; {displacement}
@!fd:boolean; {a final |disp_node| pair?}
@!tx:pointer; {effective tail node}
@!m:quarterword; {the length of a replacement list}
@y
@!a_dir:eight_bits; {adjust direction}
@!d:pointer; {last |disp_node|}
@!disp,@!pdisp:scaled; {displacement}
@!pp,@!pnode:pointer;
@!f:boolean; {will |d| free?}
@!m:quarterword; {the length of a replacement list}
@z

@x [47.1080] l.20940
@d fetch_effective_tail==fetch_effective_tail_pTeX
@y
@d fetch_effective_tail_epTeX(#)==
@#
@d fetch_effective_tail==fetch_effective_tail_epTeX
@z

@x [47.1080] l.20950
else  begin if not is_char_node(tail)and(head<>tail) then
    begin find_effective_tail(goto done);
    if (type(tx)=hlist_node)or(type(tx)=vlist_node) then
      @<Remove the last box, unless it's part of a discretionary@>;
    done:end;
@y
else  begin f:=false;
  if (not is_char_node(tail))and(type(tail)=disp_node) then
    begin d:=tail; tail:=prev_node;
    end
  else d:=null;
  if (not is_char_node(tail))and(head<>tail) then
    if (type(tail)=hlist_node)or(type(tail)=vlist_node)
          or(type(tail)=dir_node) then
      @<Remove the last box, unless it's part of a discretionary@>;
  if d<>null then
    if (not is_char_node(tail))and(type(tail)=disp_node) then
      begin prev_node:=pnode; prev_disp:=pdisp;
      {|if prev_disp=disp_dimen(d) then free_node(tail,small_node_size)|}
      if prev_disp<>disp_dimen(d) then disp_dimen(tail):=disp_dimen(d);
      if f then free_node(d,small_node_size)
      else begin prev_node:=tail; tail_append(d); end;
      end
    else tail_append(d);
@z

@x [47.1081] l.20957
begin fetch_effective_tail(goto done);
cur_box:=tx; shift_amount(cur_box):=0;
if type(cur_box)=dir_node then
  begin link(list_ptr(cur_box)):=cur_box;
  cur_box:=list_ptr(cur_box);
  list_ptr(link(cur_box)):=null;
  end
else
  if box_dir(cur_box)=dir_default then set_box_dir(cur_box)(abs(direction));
end
@y
begin q:=head; pp:=null; pnode:=null; disp:=0; pdisp:=0;
repeat p:=q;
if not is_char_node(q) then
  if type(q)=disc_node then
    begin for m:=1 to replace_count(q) do p:=link(p);
    if p=tail then goto done;
    end
  else if type(q)=disp_node then
    begin pnode:=pp; pdisp:=disp; disp:=disp_dimen(q);
    end;
pp:=q; q:=link(p);
until q=tail;
cur_box:=tail; shift_amount(cur_box):=0;
tail:=p; link(p):=null;
if type(cur_box)=dir_node then
  begin link(list_ptr(cur_box)):=cur_box;
  cur_box:=list_ptr(cur_box);
  list_ptr(link(cur_box)):=null;
  end
else
  if box_dir(cur_box)=dir_default then set_box_dir(cur_box)(abs(direction));
done:end
@z

@x [47.1105] l.21246
@!r:pointer; {running behind |p|}
@!disp,@!pdisp:scaled; {displacement}
@!fd:boolean; {a final |disp_node| pair?}
@!tx:pointer; {effective tail node}
@!m:quarterword; {the length of a replacement list}
@y
@!d:pointer; {last |disp_node|}
@!disp,@!pdisp:scaled; {displacement}
@!pp,@!pnode:pointer;
@!f:integer;
  {0: not append |d|, 1: append |d| (|tail| is removed)}
  {2: |tail| is not removed }
@!m:quarterword; {the length of a replacement list}
@z

@x [47.1105] l.21250
else if not is_char_node(tail) then
  begin find_effective_tail(return);
  if type(tx)<>cur_chr then return;
  fetch_effective_tail(return);
  flush_node_list(tx);
@y
else  begin
  if (not is_char_node(tail))and(type(tail)=disp_node) then
    begin f:=2; d:=tail; tail:=prev_node; link(tail):=null;
    end
  else d:=null;
  if not is_char_node(tail) then if type(tail)=cur_chr then
    begin q:=head; pp:=null; pnode:=null; disp:=0; pdisp:=0; f:=0;
    repeat p:=q;
    if not is_char_node(q) then
      if type(q)=disc_node then
        begin for m:=1 to replace_count(q) do p:=link(p);
        if p=tail then
          begin if d<>null then tail_append(d);
          return;
          end
        else if link(p)=tail then f:=1;
        end
      else if type(q)=disp_node then
        begin pnode:=pp; pdisp:=disp; disp:=disp_dimen(q);
        end;
    pp:=q; q:=link(p);
    until q=tail;
    link(p):=null; flush_node_list(tail); tail:=p;
    end;
  if d<>null then
    if f<=1 then
      begin prev_node:=pnode; prev_disp:=pdisp;
      if (f=0)and(not is_char_node(tail))and(type(tail)=disp_node) then
        begin disp_dimen(tail):=disp_dimen(d); free_node(d,small_node_size)
        end
      else begin prev_node:=tail; prev_disp:=disp; tail_append(d);
        end;
      end
    else tail_append(d);
@z

@x e-pTeX: font_char_{wd,ht,dp,ic}_code l.27306
    begin i:=char_info(q)(qi(cur_val));
@y
    begin i:=orig_char_info(q)(qi(cur_val));
@z

@x e-pTeX: displacement value when typesetting right-to-left l.27798
@!LR_temp:pointer; {holds a temporarily removed \.{\\endM} node}
@y
@!revdisp:scaled; {temporary value of displacement}
@!LR_temp:pointer; {holds a temporarily removed \.{\\endM} node}
@z

@x e-pTeX: reverse nodes of an hlist l.28010
var l:pointer; {the new list}
@y
var l,la:pointer; {the new list}
disp,disp2: scaled; { displacement } disped: boolean;
@z
@x e-pTeX: reverse nodes of an hlist l.28010
begin g_order:=glue_order(this_box); g_sign:=glue_sign(this_box);
@y 
begin g_order:=glue_order(this_box); g_sign:=glue_sign(this_box);
disp:=revdisp; disped:=false;
@z
@x e-pTeX: reverse nodes of an hlist l.28010
done:reverse:=l;
@y
done: {if the beginning node of the new list isn't |disp_node|,
       we insert |disp_node| to fix.}
if (l<>null)and(type(l)<>disp_node) then begin
  p:=get_node(small_node_size); type(p):=disp_node;
  disp_dimen(p):=disp; link(p):=l; reverse:=p;
  end
else reverse:=l;
@z
@x e-pTeX: reverse nodes of an hlist l.28010
  q:=link(p); link(p):=l; l:=p; p:=q;
@y
  if font_dir[f]<>dir_default then begin
    q:=link(p); la:=l; l:=p; p:=link(q); link(q):=la;
    end
  else begin q:=link(p); link(p):=l; l:=p; p:=q; end;
@z
@x e-pTeX: reverse nodes of an hlist l.28010
othercases goto next_p
@y
disp_node: begin
  disp2:=disp_dimen(p); disp_dimen(p):=disp; disp:=disp2;
  { print_nl("ep TeXXeT:"); print_int(disp_dimen(p)); }
  { print(" -> "); print_int(disp); }
  { if not disped then begin disped:=true; print(" NL"); end; end; }
  if not disped then disped:=true; end;
othercases goto next_p
@z

@x e-pTeX: ifcsname l.28620
  buffer[m]:=info(p) mod @'400; incr(m); p:=link(p);
@y
  if check_kanji(info(p)) then {wchar_token}
    begin buffer[m]:=Hi(info(p)); incr(m);
    end;
  buffer[m]:=Lo(info(p)); incr(m); p:=link(p);
@z

@x e-pTeX: if_font_char_code l.28633
    b:=char_exists(char_info(n)(qi(cur_val)))
@y
    b:=char_exists(orig_char_info(n)(qi(cur_val)))
@z

@x
procedure print_direction(@!d:integer); {print the direction represented by d}
@y
procedure print_direction_alt(@!d:integer);
var x: boolean;
begin x:=false;
case abs(d) of
dir_yoko: begin print(", yoko"); x:=true; end;
dir_tate: begin print(", tate"); x:=true; end;
dir_dtou: begin print(", dtou"); x:=true; end;
end;
if x then begin if d<0 then print("(math)");
print(" direction"); end;
end;
@#
procedure print_direction(@!d:integer); {print the direction represented by d}
@z


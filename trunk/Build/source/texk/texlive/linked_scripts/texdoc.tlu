#!/usr/bin/env texlua
-- $Id: texdoc.tlu 9776 2008-07-25 23:58:05Z mpg $
--[[ Revised by Manuel Pégourié-Gonnard and Reinhard Kotucha, 2008.
First texlua version by Frank Küster (2007) based on the shell script by
Thomas Esser, David Aspinall, and Simon Wilkinson.
Public domain.]]
--[[ Changelog
  0.4 2008-07
  - moved configuration from texmf.cnf to texdoc.cnf
  - added an 'alias' feature
  - new 'mixed' mode (view or list)
  - file lists are now menus (press a key to view results)
  - changed the search modes to get only the more relevant results (hopefully)
  - /!\ zip support disabled by default (see comments below), not portable

  0.3 2007-06-28
  - added changelog
  - better OS detection for default viewer settings
  - removed some debugging code
  - -s now works in dirs without ls-R, too
  
  0.2 2007-06-28
  - implemented reading of configuration from texmf.cnf
  - fixed "-s" option
  
  0.1
  - initial public release 
]]

-- some constants 
progname = 'texdoc'
version = '0.4beta'
usage_msg = [[
Usage:  texdoc  -h, --help | -V, --version | [option] name(s)
    -h|--help       Show this help.
    -V|--version    Print the version of the program.
    -v|--verbose    Show the command being used to display the documentation.
    -a|--alias      Use the alias table.
    -A|--noalias    Don't use the alias table.
    -e|--extension  Search only for files of given type (extension).
    -w|--view       Use view mode: start a viewer.
    -m|--mixed      Use mixed mode (view or list).
    -l|--list       Use list mode: don't start a viewer.
    -s|--search     Search for name as a lua regex.]]
notfound_msg = [[
Sorry, no documentation found for PKGNAME.
Perhap's you'll be more lucky with the CTAN catalogue's search tool at 
http://ctan.org/search.html#byDescription.]]
place_holder = '%%s' -- used for viewer commands

-- zip/gz support
--
-- optionally, texdoc can support compressed documentation, but this is
-- system-dependant (commands for unzipping, temporary files, etc).
-- Since TeX Live doesn't ship compressed doc, downstream distributors who
-- want to ship zipped should change support_zipped to true *and* make sure
-- everything  works for them (look for support_zipped in the code).
-- If you use this feature, please let us know: if nobody uses it,
-- we'll drop it at some point.
support_zipped = false


-- BEGIN function definitions (till the 'END' mark)
---=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

-- a general-use function
function list (t)
    local i = 0
    return function ()
        i = i + 1
        return t[i]
    end
end

-- Remark: we always assume our tables have no hole (that is, no nil value
-- followed by a non-nil value). So we use the simple iterator above, and 
-- the # operator sometimes (bit faster than table.getn).

-- functions for the search options
-----------------------------------

-- full tree exploration with or without ls-R file

-- check which texmf roots have a ls-R file (returns an iterator for those)
-- and which don't (put them in the global no_lsr_trees) (bad)
no_lsr_doctrees = {}
function get_lsr_files ()
    local lsr_files = {}
    local pathlist = kpse.expand_braces('$TEXDOCS')
    for path in string.gmatch(pathlist, "[^:;]+") do
        path = string.gsub(path,'//$','')
        local tree_root
        tree_root = string.gsub(path,'doc$','')
        tree_root = string.gsub(tree_root,'^!!','')
        if lfs.isfile(tree_root .. "ls-R") then
            table.insert(lsr_files,tree_root .. "ls-R")
        else
            if not string.match(path,'^%.$') and lfs.isdir(path) then
                table.insert(no_lsr_doctrees,path)
            end
        end -- does lsRfile exist?
    end -- for path
    local i = 0
    local n = table.getn(lsr_files)
    return function ()
        i = i +1
        if i <= n then return lsr_files[i] end
    end
end

-- protect - in patterns instead of trusting the user to do that 
function deluaficate(oldpat)
    local newpat
    -- better use long strings here, no escaping of \ needed there.
    newpat = string.gsub(oldpat,'([^\\])%-','%1%%%-')
    newpat = string.gsub(newpat,'\\','')
    return newpat
end --deluaficate

-- return files in the TEXDOCS tree whose full path matches against pattern
function pattern_search (pattern)
    docfiles = {} -- should not be local (used in recurse_tree)
    pattern = deluaficate(pattern)
    -- populate docfiles list
    for database in get_lsr_files() do
        local texmf_tree = string.gsub(database,'ls%-R$','')
        is_docline = false
        local this_dir -- changed to each individual docdir
        for line in io.lines(database) do
            if string.match(line,'^./') then
                -- a directory
                this_dir = string.gsub(line,'^./',texmf_tree)
                this_dir = string.gsub(this_dir,':$','/')
                if string.match(line,'^./doc') then
                    -- the next file lines are in docdir "this_dir"
                    is_docline = true
                else
                    is_docline = false
                end -- docdir
            elseif string.match(line,'^%s*$') then
                -- empty line, do nothing
                -- now we have only file lines left, are they a docline?
            elseif is_docline then
                local fullpath = this_dir .. line
                if string.match(fullpath, pattern) then
                    if lfs.isfile(fullpath) then -- cannot know from ls-R
                        table.insert(docfiles,fullpath)
                    end
                end
            end -- line starting with ./
        end -- for line
    end -- for database
    for no_lsr_dir in list(no_lsr_doctrees) do
        recurse_tree(no_lsr_dir, pattern)
    end
    return docfiles
end

-- recursively explore a tree and put the file matching pattern in docfiles
function recurse_tree (path, pattern)
    for file in lfs.dir(path) do
        if file ~= "." and file ~= ".." then
            local f = path..'/'..file
            local attr = lfs.attributes (f)
            if attr then -- else stale symlink
                if attr.mode == "directory" then
                    recurse_tree (f, pattern)
                else
                    if string.match (f, pattern) then
                        table.insert(docfiles,f)
                    end
                end
            end
        end
    end
end


-- filename and mixed search modes

-- add a dot to ext except if it's empty
function dotted(ext)
    if (ext == '') then 
        return ext
    else
        return '.'..ext
    end
end

-- simple search on filename using kpse
function filename_search (filename)
    files = {}
    for ext in list(config.ext_list) do
        found = kpse.find_file(filename .. dotted(ext),
        "TeX system documentation")
        if found then table.insert(files, found) end
    end
    return files
end

-- do a filename search and try a full search if unsuccessfull
function mixed_search (filename, alternative)
    results = filename_search (filename)
    if not results[1] then 
        print ("texdoc info: No result with simple search, "..
        "trying full search mode.")
        results = pattern_search (alternative)
    end
    return results
end


-- functions to set config values and aliases
---------------------------------------------

-- set a value without overwriting if already set
function set_config_element (key, value)
    if config[key] == nil then
        if string.match(key, '_list$') then
            -- this is actually a coma-separeted list of values
            local values = string.explode(value, ',')
            for i, j in ipairs(values) do
                values[i] = string.gsub(j, '%s*$', '')
                values[i] = string.gsub(j, '^%s*', '')
            end
            config[key] = values
        else
            config[key] = value
        end
    end
end

-- set a whole list, also whithout overwriting
function set_config_list (conf)
    for key, value in pairs(conf) do
        set_config_element (key, value)
    end
end

-- set an alias (w/o overwriting)
function set_alias (key, value)
    if alias[key] == nil then
        alias[key] = value
    end
end

-- set config from environment if available
function setup_config_from_env ()
    set_config_list {
        viewer_pdf  = os.getenv ("PDFVIEWER"),
        viewer_ps   = os.getenv ("PSVIEWER"),
        viewer_dvi  = os.getenv ("DVIVIEWER"),
        viewer_html = os.getenv ("BROWSER"),
        viewer_txt  = os.getenv ("PAGER")
    }
end

-- set config+aliases from a particular config file if it exists
function read_config_file(configfile)
    if (lfs.isfile(configfile)) then -- configfile exists
        local cnf = assert(io.open(configfile, 'r')) 
        local lineno = 0
        while true do
            local key, val
            local line=cnf:read('*line')
            lineno = lineno + 1
            if line == nil then break end  -- EOF
            line = string.gsub(line, '%s*#.*$', '') -- comments begin with #
            line = string.gsub(line, '%s*$', '')    -- remove trailing spaces
            line = string.gsub(line, '^%s*', '')    -- remove leading spaces
            key, val=string.match(line, '^([%a%d_]+)%s*=%s*(.+)')
            if key and val then 
                set_config_element(key, val)
            else
                key, val = string.match(line, '^alias%s+([%a%d_-]+)%s*=%s*(.+)')
                if key and val then
                    set_alias(key, val)
                else
                    if (not string.match (line, '^%s*$')) then
                        print ('texdoc warning: syntax error in '..configfile..
                        ' at line '..lineno..'.')
                    end
                end
            end
        end
        cnf:close()
    end
end

-- set config/aliases from all config files 
function setup_config_from_files ()
    local TEXMFHOME, TEXMFLOCAL, TEXMFMAIN
    local platform, configfile, configfiles
    local ext, command, default_viewer
    --
    platform=string.match(kpse.var_value('SELFAUTOLOC'), '.*/(.*)$')
    TEXMFHOME=kpse.var_value('TEXMFHOME')
    TEXMFLOCAL=kpse.var_value('TEXMFLOCAL')
    TEXMFMAIN=kpse.var_value('TEXMFMAIN')
    --
    -- the following config files are read if they exist.
    configfiles={
        TEXMFHOME ..'/texdoc/texdoc-'..platform..'.cnf',
        TEXMFHOME ..'/texdoc/texdoc.cnf',
        TEXMFLOCAL..'/texdoc/texdoc-'..platform..'.cnf',
        TEXMFLOCAL..'/texdoc/texdoc.cnf',
        TEXMFMAIN..'/texdoc/texdoc.cnf'
    }
    --
    for i, configfile in ipairs(configfiles) do -- process all config files
        read_config_file(configfile)
    end
end

-- for default viewer on general Unix, we have a list; the following two
-- functions are used to check in the path which program is available

-- check if "name" is the name of a file in the path
-- Warning: to be used only on Unix! (separators, and PATH irrelevant on win32)
function is_in_path(name)
    local path_list = string.explode(os.getenv("PATH"), ':')
    for _, path in ipairs(path_list) do
        if lfs.isfile(path..'/'..name) then return true end
    end
    return false
end

-- return the first element of "list" whose name is found in path, or nil
function first_in_path(cmds)
    for _, cmd in ipairs(cmds) do
        if is_in_path(cmd[1]) then return cmd[2] end
    end
    return nil
end

-- set some fall-back default values if no previous value is set
function setup_config_from_defaults()
    if (os.type == "windows") then
        -- probably Windows (or OS/2)
        -- which commands should we use for unzipping?
        set_config_list {
            viewer_dvi    = 'start',
            viewer_html   = 'start',
            viewer_pdf    = 'start',
            viewer_ps     = 'start',
            viewer_txt    = 'start',
        }
    else -- since we don't support msdos, if os.type is not windows, it's unix
        if (os.name == 'macosx') then
            set_config_list {
                viewer_dvi    = '(open %s)',
                viewer_html   = '(open %s)',
                viewer_pdf    = '(open %s)',
                viewer_ps     = '(open %s)',
                viewer_txt    = 'less',
            }
        else
            set_config_list {
                viewer_dvi      = first_in_path {
                    {'evince',  '(evince %s) &'},
                    {'okular',  '(okular %s) &'},
                    {'kdvi',    '(kdvi %s) &'},
                    {'xdvi',    '(xdvi %s) &'},
                    {'see',     '(see %s) &'}
                },
                viewer_html     = first_in_path {
                    {'firefox',     '(firefox %s) &'},
                    {'mozilla',     '(mozilla %s) &'},
                    {'konqueror',   '(konqueror %s) &'},
                    {'epiphany',    '(epiphany %s) &'},
                    {'opera',       '(opera %s) &'},
                    {'w3m',         'w3m'},
                    {'links',       'links'},
                    {'lynx',        'lynx'},
                    {'see',         'see'}
                },
                viewer_pdf      = first_in_path {
                    {'evince',  '(evince %s) &'},
                    {'okular',  '(okular %s) &'},
                    {'kpdf',    '(kpdf %s) &'},
                    {'xpdf',    '(xpdf %s) &'},
                    {'see',     '(see %s) &'}
                },
                viewer_ps       = first_in_path {
                    {'evince',  '(evince %s) &'},
                    {'okular',  '(okular %s) &'},
                    {'kghostview', '(kghostview %s) &'},
                    {'gv',      '(gv %s) &'},
                    {'see',     '(see %s) &'}
                },
                viewer_txt      = first_in_path {
                    {'most',    'most'},
                    {'less',    'less'},
                    {'more',    'more'}
                }
            }
        end
    end
    -- now a particular case for config.ext_list and zip-related stuff
    -- Note: removed texdoc_formats/zip_formats, gives simpler & generic code
    if support_zipped then
        set_config_element('ext_list', 
        'pdf,pdf.gz,pdf.bz2, html,html.gz,html.bz2, txt,txt.gz,txt.bz2,'..
        'dvi,dvi.gz,dvi.bz2, ps,ps.gz,ps.bz2')
        set_config_list {
            unzip_gz    = 'gzip -d -c ',
            unzip_bz2   = 'bzip -d -c ',
            rm_file     = 'rm -f',
            rm_dir      = 'rmdir'
        }
    else
        set_config_element('ext_list', 'pdf, html, txt, dvi, ps')
    end
end


-- functions for viewing/displaying the results
-----------------------------------------------

-- prepare for viewing: set viewer_replacement and viewer_ext
-- may uncompress if support_zipped is set (giving the complete filename on the
-- command line is unsupported for compressed files by the way)
function how_to_view (filename)
    if support_zipped then
        ext = string.match(filename,'.*%.(.*)$')
        zipext = string.match(ext,'^.*%.(.*)')
        if zipext then
            unzip_command = config['unzip_'..zipext]
            viewext = string.match(ext,'^(.*)%..*$')
            basename_pattern = '.*/(.*%.' .. viewext .. ')'
            basename = string.match(filename,basename_pattern)
            tmpdir = os.tmpdir("/tmp/texdoc.XXXXXX")
            unzip_commandline = unzip_command .. filename .. " > " 
            .. tmpdir .. "/" .. basename
            if os.execute(unzip_commandline) then
                filename = tmpdir .. "/" .. basename
            else
                print("Error executing \n" .. unzip_commandline)
            end
            viewer_replacement = filename .. ';' .. config.rm_file
            .. filename .. ';' .. config.rm_dir .. tmpdir
        end
    else
        ext = string.match(filename,'.*%.(.*)$')
        viewer_replacement = filename
        viewext = ext
        if not viewext then
            print ("texdoc warning: cannot determine file type for\n"..
            filename..", assuming text.")
            viewext = 'txt'
        else
            if not config['viewer_'..viewext] then
                print ("texdoc warning: no "..viewext.." viewer found, "..
                "using text viewer instead.\nYou can select you preffered"..
                "with the viewer_"..viewext.." variable in texdoc.cnf.")
                viewext = 'fallback'
                if not config['viewer_'..viewext] then
                    print ("texdoc error: text viewer not found. "..
                    "Skipping file "..filename..".")
                end
            end -- viewer for ext
        end -- no ext
    end -- zipped or not
    return config['viewer_'..viewext], viewer_replacement
end

-- view a file, if possible
function try_viewing (view_command, viewer_replacement)
    if not view_command then
        view_result = false
    else
        if string.match (view_command, place_holder) then
            view_command = string.gsub(
            view_command, place_holder, '"'..viewer_replacement..'"')
        else
            view_command = view_command..' "'..viewer_replacement..'"'
        end
        if verbose then
            print(view_command)
        end
        view_result = os.execute(view_command)
        if not view_result then
            print("texdoc error: the following command failed\n\t" 
            .. view_command)
        end
    end
    return view_result
end

-- display the results of a search and let user choose
function print_ordered_byext (files_list)
    for _, ext in ipairs (config.ext_list) do
        if ext == '' then 
            ext_pattern = '/[^.]*$'
        elseif ext == '*' then
            ext_pattern = ''
        else
            ext_pattern = '%.'..ext..'$'
        end
        for file in list(files_list) do
            if string.match (file, ext_pattern) then print (file) end
        end 
    end
end

-- compare two files with the following rule:
-- 1. extensions are ordered as in ext_list first,
-- 2. then filenames lexicograhpicaly.
function file_order (a, b)
    local ext_a = string.match (a, '^.*%.(.*)$')
    local ext_b = string.match (b, '^.*%.(.*)$')
    if ext_pos(ext_a) < ext_pos(ext_b) then
        return true
    elseif ext_pos(ext_a) > ext_pos(ext_b) then
        return false
    else
        return (a < b)
    end
end

-- return the position of ext in ext_list, and greater value if not in ext_list
-- magic inside: compute ext_reverse only once
function ext_pos (ext)
    local ext_rev = {}
    local max
    for i, ext in ipairs (config.ext_list) do
        ext_rev[ext] = i
        max = i
    end
    ext_pos = function (e)
        return ext_rev[e] or (max + 1)
    end
    return ext_pos (ext)
end

-- print a list of files as a menu
function print_menu (files)
    local n = #files
    if n > 20 then 
        io.write (n, " files found.  Display the complete list? (y/N) ")
        local ans = io.read(1)
       if not ((ans == 'y') or (ans == 'Y')) then return end
    end
    -- table.sort(results, file_order)
    for i, file in ipairs (files) do
        print (i, file)
    end
    io.write ("Please enter the number of the file to view, or 0 to exit: ")
    local num = io.read('*number')
    if num and files[num] then
        print ("Viewing file '"..files[num].."'.")
    elseif num ~= 0 then
        print ("Incorrect input, skipping.")
    end
end

-- apologize/complain if something went wrong
function apologize (reason, name)
    if reason == 'notfound' then
        exit_code = 2
        msg = string.gsub (notfound_msg, 'PKGNAME', name)
        print (msg) -- to get rid of gsub's 2nd value
    else
        exit_code = 255
        print ('texdoc error: Oops, this should not happen'..
        ' (unknown error code).  Sorry.')
    end
end


-- END of function definitions: here starts the execution
--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

-- exit codes (probably make sense only with a single argument)
-- 0    OK
-- 1    Usage
-- 2    No doc found for at least one arg
-- ?    Should do something for viewer problems etc

-- must have at least one arg
if not arg[1] then
    print (usage_msg)
    os.exit(1)
end

-- options from command line
----------------------------

-- there is one boolean switch: verbose
-- and config options using the config table, which means the default comes last
-- config options are: 
--      mode ('view'* or 'list' or 'search')
--      enable_alias ('true'* or 'false' (string, not boolean))
--      ext_list via the -t option
verbose = false
config = {} -- everything is stored in this table ...
alias = {}  -- ... except aliases
while table.maxn(arg) > 0 and string.match(arg[1],'^%-') do
    curr_arg = table.remove(arg,1)
    if (curr_arg == '-h') or (curr_arg == '--help') then
        print (usage_msg)
        os.exit(0)
    elseif (curr_arg == '-V') or (curr_arg == '--version') then
        print (progname .. ' version: ' .. version )
        os.exit(0)
    elseif (curr_arg == '-v') or (curr_arg == '--verbose') then
        verbose = true
    elseif (curr_arg == '-w') or (curr_arg == '--view') then
        set_config_element('mode', 'view')
    elseif (curr_arg == '-m') or (curr_arg == '--mixed') then
        set_config_element('mode', 'mixed')
    elseif (curr_arg == '-l') or (curr_arg == '--list') then
        set_config_element('mode', 'list')
    elseif (curr_arg == '-s') or (curr_arg == '--search') then
        set_config_list { mode = 'search', enable_alias = 'false'}
    elseif (curr_arg == '-A') or (curr_arg == '--alias') then
        set_config_element('enable_alias', 'false')
    elseif (curr_arg == '-a') or (curr_arg == '--noalias') then
        set_config_element('enable_alias', 'true')
    elseif string.match(curr_arg, '^-t') then 
        set_config_element('ext_list', string.gsub(curr_arg, '^-t=?', ''))
    elseif string.match(curr_arg, '^--type') then
        set_config_element('ext_list', string.gsub(curr_arg, '^--type=?', ''))
    else
        print ("texdoc error: unknow option: "..curr_arg)
    end
end

-- defaults using the config table (ext_list comes later)
set_config_list {
    enable_alias    = 'true', -- string, not boolean
    mode            = 'view',
}

-- must have at least one arg left after eating up the options
if not arg[1] then
    print (usage_msg)
    os.exit(1)
end


-- initialisations
------------------

-- initialize kpathsea
kpse.set_program_name(arg[-1], "texdoc")

-- config options from env, conf files or defaults
setup_config_from_env ()
setup_config_from_files ()
setup_config_from_defaults ()

-- we want an empty string for ext at the beginning, so that it works to specify
-- the complete filename (at least in list or view mode).  Doesn't matter when
-- there's one more empty string, but we can easily avoid two in a row
-- TODO: should be dealt with another way
if (config.mode ==  'view' or config.mode == 'list') then
    if not (config.ext_list[1] == '') then
        table.insert(config.ext_list,1,'')
    end
end

-- the main loop over the args
exit_code = 0
for docname in list (arg) do
    original_docname = docname
    if (alias[docname] and (config.enable_alias == 'true')) then
        print ("texdoc info: "..docname.." aliased to "..alias[docname])
        docname = alias[docname]
    end
    local docfound = false
    if (config.mode == 'search') then
        results = pattern_search (docname)
        if results[1] then
            print_menu (results)
        else
            apologize ('notfound', docname)
        end
    elseif (config.mode == 'list') then
        results = mixed_search (docname, original_docname)
        if results[1] then
            print_menu (results)
        else
            apologize ('notfound', docname)
        end
    elseif (config.mode == 'view') then
        results = mixed_search (docname, original_docname)
        if results[1] then 
            try_viewing (how_to_view(results[1]))
        else
            apologize ('notfound', docname)
        end
    elseif (config.mode == 'mixed') then
        results = mixed_search (docname, original_docname)
        if (not results[1]) then        -- no results
            apologize ('notfound', docname)
        elseif (not results[2]) then    -- 1 result (faster than table.maxn)
            local ok = try_viewing (how_to_view(results[1]))
            if not ok then apologize ('oops') end
        else                            -- 2 or more results
            print_menu (results)
        end
    end -- if construct "case config.mode in"
end -- for docname in arg

os.exit(exit_code)

-- Local Variables:
-- lua-indent-level: 4
-- tab-width: 4
-- indent-tabs-mode: nil
-- End:
-- vim: sw=4 ts=4 expandtab:

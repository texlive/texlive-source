Index: mendex.1
===================================================================
--- mendexk2.6e.orig/mendex.1
+++ mendexk2.6e/mendex.1
@@ -59,6 +59,9 @@
 .TP 10
 \fB-S\fR
 漢字コードをShiftJISに指定します。入力ファイル、出力ファイルともShiftJISとして扱います。
+.TP 10
+\fB-U\fR
+漢字コードをUTF-8に指定します。入力ファイル、出力ファイルともUTF-8として扱います。
 
 
 .SH スタイルファイル
Index: configure
===================================================================
--- mendexk2.6e.orig/configure
+++ mendexk2.6e/configure
@@ -1,9 +1,7 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.63 for makeindex for TeX Live 2.15.
+# Generated by GNU Autoconf 2.63 for mendex for TeX Live 2.6f.
 #
-# Report bugs to <tex-k@tug.org>.
-#
 # Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
 # 2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
 # This configure script is free software; the Free Software Foundation
@@ -743,13 +741,13 @@
 SHELL=${CONFIG_SHELL-/bin/sh}
 
 # Identity of this package.
-PACKAGE_NAME='makeindex for TeX Live'
-PACKAGE_TARNAME='makeindex-for-tex-live'
-PACKAGE_VERSION='2.15'
-PACKAGE_STRING='makeindex for TeX Live 2.15'
-PACKAGE_BUGREPORT='tex-k@tug.org'
+PACKAGE_NAME='mendex for TeX Live'
+PACKAGE_TARNAME='mendex-for-tex-live'
+PACKAGE_VERSION='2.6f'
+PACKAGE_STRING='mendex for TeX Live 2.6f'
+PACKAGE_BUGREPORT=''
 
-ac_unique_file="mkind.c"
+ac_unique_file="main.c"
 # Factoring default headers for most tests.
 ac_includes_default="\
 #include <stdio.h>
@@ -790,6 +788,10 @@
 am__EXEEXT_TRUE
 LTLIBOBJS
 LIBOBJS
+PTEXENC_RULE
+PTEXENC_DEPEND
+PTEXENC_LIBS
+PTEXENC_INCLUDES
 KPATHSEA_RULE
 KPATHSEA_DEPEND
 KPATHSEA_LIBS
@@ -1480,7 +1482,7 @@
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures makeindex for TeX Live 2.15 to adapt to many kinds of systems.
+\`configure' configures mendex for TeX Live 2.6f to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
@@ -1529,7 +1531,7 @@
   --localedir=DIR         locale-dependent data [DATAROOTDIR/locale]
   --mandir=DIR            man documentation [DATAROOTDIR/man]
   --docdir=DIR            documentation root
-                          [DATAROOTDIR/doc/makeindex-for-tex-live]
+                          [DATAROOTDIR/doc/mendex-for-tex-live]
   --htmldir=DIR           html documentation [DOCDIR]
   --dvidir=DIR            dvi documentation [DOCDIR]
   --pdfdir=DIR            pdf documentation [DOCDIR]
@@ -1551,7 +1553,7 @@
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of makeindex for TeX Live 2.15:";;
+     short | recursive ) echo "Configuration of mendex for TeX Live 2.6f:";;
    esac
   cat <<\_ACEOF
 
@@ -1598,7 +1600,6 @@
 Use these variables to override the choices made by `configure' or to help
 it to find libraries and programs with nonstandard names/locations.
 
-Report bugs to <tex-k@tug.org>.
 _ACEOF
 ac_status=$?
 fi
@@ -1661,7 +1662,7 @@
 test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
-makeindex for TeX Live configure 2.15
+mendex for TeX Live configure 2.6f
 generated by GNU Autoconf 2.63
 
 Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
@@ -1675,7 +1676,7 @@
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by makeindex for TeX Live $as_me 2.15, which was
+It was created by mendex for TeX Live $as_me 2.6f, which was
 generated by GNU Autoconf 2.63.  Invocation command line was
 
   $ $0 $@
@@ -4328,13 +4329,13 @@
 else
   lt_cv_nm_interface="BSD nm"
   echo "int some_variable = 0;" > conftest.$ac_ext
-  (eval echo "\"\$as_me:4331: $ac_compile\"" >&5)
+  (eval echo "\"\$as_me:4332: $ac_compile\"" >&5)
   (eval "$ac_compile" 2>conftest.err)
   cat conftest.err >&5
-  (eval echo "\"\$as_me:4334: $NM \\\"conftest.$ac_objext\\\"\"" >&5)
+  (eval echo "\"\$as_me:4335: $NM \\\"conftest.$ac_objext\\\"\"" >&5)
   (eval "$NM \"conftest.$ac_objext\"" 2>conftest.err > conftest.out)
   cat conftest.err >&5
-  (eval echo "\"\$as_me:4337: output\"" >&5)
+  (eval echo "\"\$as_me:4338: output\"" >&5)
   cat conftest.out >&5
   if $GREP 'External.*some_variable' conftest.out > /dev/null; then
     lt_cv_nm_interface="MS dumpbin"
@@ -5540,7 +5541,7 @@
   ;;
 *-*-irix6*)
   # Find out which ABI we are using.
-  echo '#line 5543 "configure"' > conftest.$ac_ext
+  echo '#line 5544 "configure"' > conftest.$ac_ext
   if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
@@ -6934,8 +6935,8 @@
 
 
 # Define the identity of the package.
- PACKAGE='makeindex-for-tex-live'
- VERSION='2.15'
+ PACKAGE='mendex-for-tex-live'
+ VERSION='2.6f'
 
 
 # Some tools Automake needs.
@@ -7492,11 +7493,11 @@
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:7495: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:7496: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:7499: \$? = $ac_status" >&5
+   echo "$as_me:7500: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings other than the usual output.
@@ -7831,11 +7832,11 @@
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:7834: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:7835: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:7838: \$? = $ac_status" >&5
+   echo "$as_me:7839: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings other than the usual output.
@@ -7936,11 +7937,11 @@
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:7939: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:7940: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:7943: \$? = $ac_status" >&5
+   echo "$as_me:7944: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -7991,11 +7992,11 @@
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:7994: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:7995: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:7998: \$? = $ac_status" >&5
+   echo "$as_me:7999: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -10791,7 +10792,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 10794 "configure"
+#line 10795 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -10887,7 +10888,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 10890 "configure"
+#line 10891 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -12237,12 +12238,7 @@
 $as_echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
     { $as_echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
 $as_echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
-    ( cat <<\_ASBOX
-## ---------------------------- ##
-## Report this to tex-k@tug.org ##
-## ---------------------------- ##
-_ASBOX
-     ) | sed "s/^/$as_me: WARNING:     /" >&2
+
     ;;
 esac
 { $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
@@ -12934,9 +12930,7 @@
 
 
 
-
-
-for ac_header in ctype.h types.h locale.h
+for ac_header in strings.h
 do
 as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
 if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
@@ -13054,12 +13048,7 @@
 $as_echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
     { $as_echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
 $as_echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
-    ( cat <<\_ASBOX
-## ---------------------------- ##
-## Report this to tex-k@tug.org ##
-## ---------------------------- ##
-_ASBOX
-     ) | sed "s/^/$as_me: WARNING:     /" >&2
+
     ;;
 esac
 { $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
@@ -13086,10 +13075,7 @@
 
 done
 
-
-
-
-for ac_func in strchr strrchr setlocale
+for ac_func in
 do
 as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
 { $as_echo "$as_me:$LINENO: checking for $ac_func" >&5
@@ -13529,7 +13515,7 @@
 Report bugs to <bug-libtool@gnu.org>."
 
 lt_cl_version="\
-makeindex for TeX Live config.lt 2.15
+mendex for TeX Live config.lt 2.6f
 configured by $0, generated by GNU Autoconf 2.63.
 
 Copyright (C) 2008 Free Software Foundation, Inc.
@@ -14529,7 +14515,22 @@
 	cd ${top_builddir}/../kpathsea && $(MAKE) $(AM_MAKEFLAGS)'
 fi
 
+## _KPSE_LIB_FLAGS: Setup ptexenc (-lptexenc) flags
+  PTEXENC_INCLUDES=`echo '-IBLD/texk -ISRC/texk' | sed \
+    -e "s,SRC/,$kpse_SRC/,g" \
+    -e "s,BLD/,$kpse_BLD/,g"`
+  PTEXENC_LIBS=`echo 'BLD/texk/ptexenc/libptexenc.la' | sed \
+    -e "s,BLD/,$kpse_BLD/,g"`
 
+  PTEXENC_DEPEND=`echo 'BLD/texk/ptexenc/libptexenc.la' | sed \
+    -e 's,BLD/,${top_builddir}/../../,g'`
+   PTEXENC_RULE='# Rebuild libptexenc
+$(PTEXENC_DEPEND): ${top_srcdir}/../ptexenc/*.[ch] ${top_builddir}/../ptexenc/ptexenc.h
+	cd ${top_builddir}/../../libs/ptexenc && $(MAKE) $(AM_MAKEFLAGS)
+${top_builddir}/../ptexenc/ptexenc.h:
+	cd ${top_builddir}/../../libs/ptexenc && $(MAKE) $(AM_MAKEFLAGS)'
+
+
 ac_config_files="$ac_config_files Makefile"
 
 
@@ -14981,7 +14982,7 @@
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
-This file was extended by makeindex for TeX Live $as_me 2.15, which was
+This file was extended by mendex for TeX Live $as_me 2.6f, which was
 generated by GNU Autoconf 2.63.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
@@ -15044,7 +15045,7 @@
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 ac_cs_version="\\
-makeindex for TeX Live config.status 2.15
+mendex for TeX Live config.status 2.6f
 configured by $0, generated by GNU Autoconf 2.63,
   with options \\"`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`\\"
 
Index: fwrite.c
===================================================================
--- mendexk2.6e.orig/fwrite.c
+++ mendexk2.6e/fwrite.c
@@ -1,23 +1,79 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <stdarg.h>
 
+#include <kpathsea/config.h>
+#include <ptexenc/ptexenc.h>
+#include "mendex.h"
+
 #include "exkana.h"
 #include "exvar.h"
 
 int line_length=0;
 
-char *convcode();
-int convputs();
+static void printpage(struct index *ind, FILE *fp, int num, char *lbuff);
+static int range_check(struct index ind, int count, char *lbuff);
+static void linecheck(char *lbuff, char *tmpbuff);
+static void crcheck(char *lbuff, FILE *fp);
 
-int indwrite(filename,ind,pagenum)
+#define TAIL(x) (x+strlen(x))
+
+/* if we don't have vsnprintf() */
+/* #define vsnprintf(buff,len,format,argptr) vsprintf(buff,format,argptr) */
+
+/*   fprintf with convert kanji code   */
+int fprintf2(FILE *fp, const char *format, ...)
+{
+    char print_buff[8000];
+    va_list argptr;
+    int n;
+
+    va_start(argptr, format);
+    n = vsnprintf(print_buff, sizeof print_buff, format, argptr);
+    va_end(argptr);
+
+    fputs(print_buff, fp);
+    return n;
+}
+
+int warn_printf(FILE *fp, const char *format, ...)
+{
+    char print_buff[8000];
+    va_list argptr;
+    int n;
+
+    va_start(argptr, format);
+    n = vsnprintf(print_buff, sizeof print_buff, format, argptr);
+    va_end(argptr);
+
+    warn++;    
+    fputs(print_buff, stderr);
+    if (fp!=stderr) fputs(print_buff, fp);
+    return n;
+}
+
+int verb_printf(FILE *fp, const char *format, ...)
+{
+    char print_buff[8000];
+    va_list argptr;
+    int n;
+
+    va_start(argptr, format);
+    n = vsnprintf(print_buff, sizeof print_buff, format, argptr);
+    va_end(argptr);
+
+    if (verb!=0)    fputs(print_buff, stderr);
+    if (fp!=stderr) fputs(print_buff, fp);
+    return n;
+}
+
+
 /*   write ind file   */
-char *filename;
-struct index *ind;
-int pagenum;
+void indwrite(char *filename, struct index *ind, int pagenum)
 {
-	int i,j,k,cc,hpoint=0;
-	unsigned char datama[256],lbuff[4096],tmp[4096];
+	int i,j,hpoint=0;
+	unsigned char datama[256],lbuff[4096];
 	FILE *fp;
 
 	if (filename[0]!='\0') fp=fopen(filename,"w");
@@ -44,7 +100,7 @@
 						fprintf(fp,"%s%s%s",lethead_prefix,symhead_negative,lethead_suffix);
 					}
 				}
-				sprintf(lbuff,"%s%s",item_0,convcode(ind[i].idx[0]));
+				sprintf(lbuff,"%s%s",item_0,ind[i].idx[0]);
 			}
 			else if (alphabet(ind[i].dic[0][0])) {
 				if (lethead_flag>0) {
@@ -53,26 +109,24 @@
 				else if (lethead_flag<0) {
 					fprintf(fp,"%s%c%s",lethead_prefix,ind[i].dic[0][0]+32,lethead_suffix);
 				}
-				sprintf(lbuff,"%s%s",item_0,convcode(ind[i].idx[0]));
+				sprintf(lbuff,"%s%s",item_0,ind[i].idx[0]);
 			}
 			else if (japanese(ind[i].dic[0])) {
 				if (lethead_flag) {
 					fputs(lethead_prefix,fp);
 					for (j=hpoint;j<(strlen(datama)/2);j++) {
 						if (ind[i].dic[0][1]<datama[j*2+1]) {
-							sprintf(tmp,"%c%c",atama[(j-1)*2],atama[(j-1)*2+1]);
-							convputs(tmp,fp);
+							fprintf(fp,"%c%c",atama[(j-1)*2],atama[(j-1)*2+1]);
 							hpoint=j;
 							break;
 						}
 					}
 					if (j==(strlen(datama)/2)) {
-						sprintf(tmp,"%c%c",atama[(j-1)*2],atama[(j-1)*2+1]);
-						convputs(tmp,fp);
+						fprintf(fp,"%c%c",atama[(j-1)*2],atama[(j-1)*2+1]);
 					}
 					fputs(lethead_suffix,fp);
 				}
-				sprintf(lbuff,"%s%s",item_0,convcode(ind[i].idx[0]));
+				sprintf(lbuff,"%s%s",item_0,ind[i].idx[0]);
 				for (hpoint=0;hpoint<(strlen(datama)/2);hpoint++) {
 					if (ind[i].dic[0][1]<datama[hpoint*2+1]) {
 						break;
@@ -81,18 +135,18 @@
 			}
 			switch (ind[i].words) {
 			case 1:
-				sprintf(&lbuff[strlen(lbuff)],"%s",delim_0);
+				sprintf(TAIL(lbuff),"%s",delim_0);
 				break;
 
 			case 2:
-				sprintf(&lbuff[strlen(lbuff)],"%s%s",item_x1,convcode(ind[i].idx[1]));
-				sprintf(&lbuff[strlen(lbuff)],"%s",delim_1);
+				sprintf(TAIL(lbuff),"%s%s",item_x1,ind[i].idx[1]);
+				sprintf(TAIL(lbuff),"%s",delim_1);
 				break;
 
 			case 3:
-				sprintf(&lbuff[strlen(lbuff)],"%s%s",item_x1,convcode(ind[i].idx[1]));
-				sprintf(&lbuff[strlen(lbuff)],"%s%s",item_x2,convcode(ind[i].idx[2]));
-				sprintf(&lbuff[strlen(lbuff)],"%s",delim_2);
+				sprintf(TAIL(lbuff),"%s%s",item_x1,ind[i].idx[1]);
+				sprintf(TAIL(lbuff),"%s%s",item_x2,ind[i].idx[2]);
+				sprintf(TAIL(lbuff),"%s",delim_2);
 				break;
 
 			default:
@@ -131,8 +185,7 @@
 					fputs(group_skip,fp);
 					if (lethead_flag!=0) {
 						fputs(lethead_prefix,fp);
-						sprintf(tmp,"%c%c",atama[(j-1)*2],atama[(j-1)*2+1]);
-						convputs(tmp,fp);
+						fprintf(fp,"%c%c",atama[(j-1)*2],atama[(j-1)*2+1]);
 						fputs(lethead_suffix,fp);
 					}
 				}
@@ -141,8 +194,7 @@
 					fputs(group_skip,fp);
 					if (lethead_flag!=0) {
 						fputs(lethead_prefix,fp);
-						sprintf(tmp,"%c%c",ind[i].dic[0][0],ind[i].dic[0][1]);
-						convputs(tmp,fp);
+						fprintf(fp,"%c%c",ind[i].dic[0][0],ind[i].dic[0][1]);
 						fputs(lethead_suffix,fp);
 					}
 				}
@@ -150,41 +202,41 @@
 
 			switch (ind[i].words) {
 			case 1:
-				sprintf(&lbuff[strlen(lbuff)],"%s%s%s",item_0,convcode(ind[i].idx[0]),delim_0);
+				sprintf(TAIL(lbuff),"%s%s%s",item_0,ind[i].idx[0],delim_0);
 				break;
 
 			case 2:
 				if (strcmp(ind[i-1].idx[0],ind[i].idx[0])!=0 || strcmp(ind[i-1].dic[0],ind[i].dic[0])!=0) {
-					sprintf(&lbuff[strlen(lbuff)],"%s%s%s",item_0,convcode(ind[i].idx[0]),item_x1);
+					sprintf(TAIL(lbuff),"%s%s%s",item_0,ind[i].idx[0],item_x1);
 				}
 				else {
 					if (ind[i-1].words==1) {
-						sprintf(&lbuff[strlen(lbuff)],"%s",item_01);
+						sprintf(TAIL(lbuff),"%s",item_01);
 					}
 					else {
-						sprintf(&lbuff[strlen(lbuff)],"%s",item_1);
+						sprintf(TAIL(lbuff),"%s",item_1);
 					}
 				}
-				sprintf(&lbuff[strlen(lbuff)],"%s",convcode(ind[i].idx[1]));
-				sprintf(&lbuff[strlen(lbuff)],"%s",delim_1);
+				sprintf(TAIL(lbuff),"%s",ind[i].idx[1]);
+				sprintf(TAIL(lbuff),"%s",delim_1);
 				break;
 
 			case 3:
 				if (strcmp(ind[i-1].idx[0],ind[i].idx[0])!=0 || strcmp(ind[i-1].dic[0],ind[i].dic[0])!=0) {
-					sprintf(&lbuff[strlen(lbuff)],"%s%s",item_0,convcode(ind[i].idx[0]));
-					sprintf(&lbuff[strlen(lbuff)],"%s%s%s",item_x1,convcode(ind[i].idx[1]),item_x2);
+					sprintf(TAIL(lbuff),"%s%s",item_0,ind[i].idx[0]);
+					sprintf(TAIL(lbuff),"%s%s%s",item_x1,ind[i].idx[1],item_x2);
 				}
 				else if (ind[i-1].words==1) {
-					sprintf(&lbuff[strlen(lbuff)],"%s%s%s",item_01,convcode(ind[i].idx[1]),item_x2);
+					sprintf(TAIL(lbuff),"%s%s%s",item_01,ind[i].idx[1],item_x2);
 				}
 				else if (strcmp(ind[i-1].idx[1],ind[i].idx[1])!=0 || strcmp(ind[i-1].dic[1],ind[i].dic[1])!=0) {
-					if (ind[i-1].words==2) sprintf(&lbuff[strlen(lbuff)],"%s%s%s",item_1,convcode(ind[i].idx[1]),item_12);
-					else sprintf(&lbuff[strlen(lbuff)],"%s%s%s",item_1,convcode(ind[i].idx[1]),item_x2);
+					if (ind[i-1].words==2) sprintf(TAIL(lbuff),"%s%s%s",item_1,ind[i].idx[1],item_12);
+					else sprintf(TAIL(lbuff),"%s%s%s",item_1,ind[i].idx[1],item_x2);
 				}
 				else {
-					sprintf(&lbuff[strlen(lbuff)],"%s",item_2);
+					sprintf(TAIL(lbuff),"%s",item_2);
 				}
-				sprintf(&lbuff[strlen(lbuff)],"%s%s",convcode(ind[i].idx[2]),delim_2);
+				sprintf(TAIL(lbuff),"%s%s",ind[i].idx[2],delim_2);
 				break;
 
 			default:
@@ -198,15 +250,11 @@
 	if (filename[0]!='\0') fclose(fp);
 }
 
-int printpage(ind,fp,num,lbuff)
 /*   write page block   */
-struct index *ind;
-FILE *fp;
-int num;
-char *lbuff;
+static void printpage(struct index *ind, FILE *fp, int num, char *lbuff)
 {
-	int i,j,k,cc,eflg,cflg;
-	char buff[4096],tmpbuff[4096],errbuff[4096],tmp[4096];
+	int i,j,k,cc;
+	char buff[4096],tmpbuff[4096],errbuff[4096];
 
 	buff[0]=tmpbuff[0]='\0';
 
@@ -225,25 +273,25 @@
 				|| ind[num].p[j].enc[0]==range_close)
 				ind[num].p[j].enc++;
 			if (strlen(ind[num].p[j].enc)>0) {
-				sprintf(buff,"%s%s%s",encap_prefix,convcode(ind[num].p[j].enc),encap_infix);
+				sprintf(buff,"%s%s%s",encap_prefix,ind[num].p[j].enc,encap_infix);
 			}
 			if (strlen(suffix_3p)>0 && (pnumconv(ind[num].p[cc].page,ind[num].p[cc].attr[0])-pnumconv(ind[num].p[j].page,ind[num].p[j].attr[0]))==2) {
-				sprintf(&buff[strlen(buff)],"%s%s",convcode(ind[num].p[j].page),suffix_3p);
+				sprintf(TAIL(buff),"%s%s",ind[num].p[j].page,suffix_3p);
 			}
 			else if (strlen(suffix_mp)>0 && (pnumconv(ind[num].p[cc].page,ind[num].p[cc].attr[0])-pnumconv(ind[num].p[j].page,ind[num].p[j].attr[0]))>=2) {
-				sprintf(&buff[strlen(buff)],"%s%s",convcode(ind[num].p[j].page),suffix_mp);
+				sprintf(TAIL(buff),"%s%s",ind[num].p[j].page,suffix_mp);
 			}
 			else if (strlen(suffix_2p)>0 && (pnumconv(ind[num].p[cc].page,ind[num].p[cc].attr[0])-pnumconv(ind[num].p[j].page,ind[num].p[j].attr[0]))==1) {
-				sprintf(&buff[strlen(buff)],"%s%s",convcode(ind[num].p[j].page),suffix_2p);
+				sprintf(TAIL(buff),"%s%s",ind[num].p[j].page,suffix_2p);
 			}
 			else {
-				sprintf(&buff[strlen(buff)],"%s%s",convcode(ind[num].p[j].page),delim_r);
-				sprintf(&buff[strlen(buff)],"%s",convcode(ind[num].p[cc].page));
+				sprintf(TAIL(buff),"%s%s",ind[num].p[j].page,delim_r);
+				sprintf(TAIL(buff),"%s",ind[num].p[cc].page);
 			}
-			sprintf(&tmpbuff[strlen(tmpbuff)],"%s",buff);
+			sprintf(TAIL(tmpbuff),"%s",buff);
 			buff[0]='\0';
 			if (strlen(ind[num].p[j].enc)>0) {
-				sprintf(&tmpbuff[strlen(tmpbuff)],"%s",encap_suffix);
+				sprintf(TAIL(tmpbuff),"%s",encap_suffix);
 			}
 			linecheck(lbuff,tmpbuff);
 			j=cc;
@@ -251,7 +299,7 @@
 				goto PRINT;
 			}
 			else {
-				sprintf(&tmpbuff[strlen(tmpbuff)],"%s",delim_n);
+				sprintf(TAIL(tmpbuff),"%s",delim_n);
 				linecheck(lbuff,tmpbuff);
 			}
 		}
@@ -259,51 +307,45 @@
 /* normal encap */
 			if (ind[num].p[j].enc[0]==range_close) {
 				sprintf(errbuff,"Warning: Unmatched range closing operator \'%c\',",range_close);
-				for (i=0;i<ind[num].words;i++) sprintf(&errbuff[strlen(errbuff)],"%s.",convcode(ind[num].idx[i]));
-				fprintf(efp,"%s\n",errbuff);
-				if (efp!=stderr) fprintf(stderr,"%s\n",errbuff);
-				warn++;
+				for (i=0;i<ind[num].words;i++) sprintf(TAIL(errbuff),"%s.",ind[num].idx[i]);
+				warn_printf(efp, "%s\n", errbuff);
 				ind[num].p[j].enc++;
 			}
 			if (strlen(ind[num].p[j].enc)>0) {
-				sprintf(&tmpbuff[strlen(tmpbuff)],"%s%s%s",encap_prefix,convcode(ind[num].p[j].enc),encap_infix);
-				sprintf(&tmpbuff[strlen(tmpbuff)],"%s%s%s",convcode(ind[num].p[j].page),encap_suffix,delim_n);
+				sprintf(TAIL(tmpbuff),"%s%s%s",encap_prefix,ind[num].p[j].enc,encap_infix);
+				sprintf(TAIL(tmpbuff),"%s%s%s",ind[num].p[j].page,encap_suffix,delim_n);
 				linecheck(lbuff,tmpbuff);
 			}
 			else {
-				sprintf(&tmpbuff[strlen(tmpbuff)],"%s%s",convcode(ind[num].p[j].page),delim_n);
+				sprintf(TAIL(tmpbuff),"%s%s",ind[num].p[j].page,delim_n);
 				linecheck(lbuff,tmpbuff);
 			}
 		}
 		else {
 /* no encap */
-			sprintf(&tmpbuff[strlen(tmpbuff)],"%s%s",convcode(ind[num].p[j].page),delim_n);
+			sprintf(TAIL(tmpbuff),"%s%s",ind[num].p[j].page,delim_n);
 			linecheck(lbuff,tmpbuff);
 		}
 	}
 
 	if (ind[num].p[j].enc[0]==range_open) {
 		sprintf(errbuff,"Warning: Unmatched range opening operator \'%c\',",range_open);
-		for (k=0;k<ind[num].words;k++) sprintf(&errbuff[strlen(errbuff)],"%s.",convcode(ind[num].idx[k]));
-		fprintf(efp,"%s\n",errbuff);
-		if (efp!=stderr) fprintf(stderr,"%s\n",errbuff);
-		warn++;
+		for (k=0;k<ind[num].words;k++) sprintf(TAIL(errbuff),"%s.",ind[num].idx[k]);
+		warn_printf(efp, "%s\n", errbuff);
 		ind[num].p[j].enc++;
 	}
 	else if (ind[num].p[j].enc[0]==range_close) {
 		sprintf(errbuff,"Warning: Unmatched range closing operator \'%c\',",range_close);
-		for (k=0;k<ind[num].words;k++) sprintf(&errbuff[strlen(errbuff)],"%s.",convcode(ind[num].idx[k]));
-		fprintf(efp,"%s\n",errbuff);
-		if (efp!=stderr) fprintf(stderr,"%s\n",errbuff);
-		warn++;
+		for (k=0;k<ind[num].words;k++) sprintf(TAIL(errbuff),"%s.",ind[num].idx[k]);
+		warn_printf(efp, "%s\n", errbuff);
 		ind[num].p[j].enc++;
 	}
 	if (strlen(ind[num].p[j].enc)>0) {
-		sprintf(&tmpbuff[strlen(tmpbuff)],"%s%s%s",encap_prefix,convcode(ind[num].p[j].enc),encap_infix);
-		sprintf(&tmpbuff[strlen(tmpbuff)],"%s%s",convcode(ind[num].p[j].page),encap_suffix);
+		sprintf(TAIL(tmpbuff),"%s%s%s",encap_prefix,ind[num].p[j].enc,encap_infix);
+		sprintf(TAIL(tmpbuff),"%s%s",ind[num].p[j].page,encap_suffix);
 	}
 	else {
-		sprintf(&tmpbuff[strlen(tmpbuff)],"%s",convcode(ind[num].p[j].page));
+		sprintf(TAIL(tmpbuff),"%s",ind[num].p[j].page);
 	}
 	linecheck(lbuff,tmpbuff);
 
@@ -313,21 +355,16 @@
 	lbuff[0]='\0';
 }
 
-int range_check(ind,count,lbuff)
-struct index ind;
-int count;
-char *lbuff;
+static int range_check(struct index ind, int count, char *lbuff)
 {
 	int i,j,k,cc1,cc2,start,force=0;
-	char buff[4096],tmpbuff[4096],errbuff[4096],tmp[4096];
+	char tmpbuff[4096],errbuff[4096];
 
 	for (i=count;i<ind.num+1;i++) {
 		if (ind.p[i].enc[0]==range_close) {
 			sprintf(errbuff,"Warning: Unmatched range closing operator \'%c\',",range_close);
-			sprintf(&errbuff[strlen(errbuff)],"%s.",convcode(ind.idx[0]));
-			fprintf(efp,"%s\n",errbuff);
-			if (efp!=stderr) fprintf(stderr,"%s\n",errbuff);
-			warn++;
+			sprintf(TAIL(errbuff),"%s.",ind.idx[0]);
+			warn_printf(efp, "%s\n", errbuff);
 			ind.p[i].enc++;
 		}
 		if (ind.p[i].enc[0]==range_open) {
@@ -343,25 +380,21 @@
 					}
 					else if (j!=i && ind.p[j].enc[0]==range_open) {
 						sprintf(errbuff,"Warning: Unmatched range opening operator \'%c\',",range_open);
-						for (k=0;k<ind.words;k++) sprintf(&errbuff[strlen(errbuff)],"%s.",convcode(ind.idx[k]));
-						fprintf(efp,"%s\n",errbuff);
-						if (efp!=stderr) fprintf(stderr,"%s\n",errbuff);
-						warn++;
+						for (k=0;k<ind.words;k++) sprintf(TAIL(errbuff),"%s.",ind.idx[k]);
+						warn_printf(efp, "%s\n", errbuff);
 						ind.p[j].enc++;
 					}
 					if (strlen(ind.p[j].enc)>0) {
-						sprintf(tmpbuff,"%s%s%s",encap_prefix,convcode(ind.p[j].enc),encap_infix);
-						sprintf(tmpbuff,"%s%s%s",convcode(ind.p[j].page),encap_suffix,delim_n);
+						sprintf(tmpbuff,"%s%s%s",encap_prefix,ind.p[j].enc,encap_infix);
+						sprintf(tmpbuff,"%s%s%s",ind.p[j].page,encap_suffix,delim_n);
 						linecheck(lbuff,tmpbuff);
 					}
 				}
 			}
 			if (j==ind.num+1) {
 					sprintf(errbuff,"Warning: Unmatched range opening operator \'%c\',",range_open);
-					for (k=0;k<ind.words;k++) sprintf(&errbuff[strlen(errbuff)],"%s.",convcode(ind.idx[k]));
-					fprintf(efp,"%s\n",errbuff);
-					if (efp!=stderr) fprintf(stderr,"%s\n",errbuff);
-					warn++;
+					for (k=0;k<ind.words;k++) sprintf(TAIL(errbuff),"%s.",ind.idx[k]);
+					warn_printf(efp, "%s\n", errbuff);
 			}
 			i=j-1;
 		}
@@ -388,27 +421,24 @@
 	else return count;
 }
 
-int linecheck(lbuff,tmpbuff)
 /*   check line length   */
-char *lbuff,*tmpbuff;
+static void linecheck(char *lbuff, char *tmpbuff)
 {
 	if (line_length+strlen(tmpbuff)>line_max) {
-		sprintf(&lbuff[strlen(lbuff)],"\n%s%s",indent_space,tmpbuff);
+		sprintf(TAIL(lbuff),"\n%s%s",indent_space,tmpbuff);
 		line_length=indent_length+strlen(tmpbuff);
 		tmpbuff[0]='\0';
 	}
 	else {
-		sprintf(&lbuff[strlen(lbuff)],"%s",tmpbuff);
+		sprintf(TAIL(lbuff),"%s",tmpbuff);
 		line_length+=strlen(tmpbuff);
 		tmpbuff[0]='\0';
 	}
 }
 
-int crcheck(lbuff,fp)
-char *lbuff;
-FILE *fp;
+static void crcheck(char *lbuff, FILE *fp)
 {
-	int i,j,cc;
+	int i;
 	char buff[4096];
 
 	for (i=strlen(lbuff);i>=0;i--) {
@@ -422,65 +452,3 @@
 		}
 	}
 }
-
-char *convcode(buff)
-/*   convert kanji code from EUC to output code   */
-unsigned char *buff;
-{
-	int i,j,cc,jflag=0;
-	static unsigned char buff2[4096];
-
-	for (i=j=0;i<strlen(buff);i++,j++) {
-		if (buff[i]=='\0') {
-			break;
-		}
-		else if (buff[i]>=0x80) {
-			if (kanji==Jis) {
-				if (!jflag) {
-					buff2[j++]=0x1b;
-					buff2[j++]=0x24;
-					buff2[j++]=0x42;
-					jflag=1;
-				}
-				buff2[j++]=buff[i++]-0x80;
-				buff2[j]=buff[i]-0x80;
-			}
-			else if (kanji==Sjis) {
-				cc=buff[i]*256+buff[i+1]-0x8080;
-				i++;
-				cc=JIStoSJIS(cc);
-				buff2[j++]=(cc>>8)&0xff;
-				buff2[j]=cc&0xff;
-			}
-			else {
-				buff2[j++]=buff[i++];
-				buff2[j]=buff[i];
-			}
-		}
-		else {
-			if (jflag) {
-				buff2[j++]=0x1b;
-				buff2[j++]=0x28;
-				buff2[j++]=0x42;
-				jflag=0;
-			}
-			buff2[j]=buff[i];
-		}
-	}
-	if (jflag) {
-		buff2[j++]=0x1b;
-		buff2[j++]=0x28;
-		buff2[j++]=0x42;
-		jflag=0;
-	}
-	buff2[j]='\0';
-	return buff2;
-}
-
-int convputs(buff,fp)
-/*   fputs width convert kanji code   */
-char *buff;
-FILE *fp;
-{
-	fputs(convcode(buff),fp);
-}
Index: Makefile.in
===================================================================
--- mendexk2.6e.orig/Makefile.in
+++ mendexk2.6e/Makefile.in
@@ -15,7 +15,6 @@
 
 @SET_MAKE@
 
-
 VPATH = @srcdir@
 pkgdatadir = $(datadir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
@@ -35,10 +34,10 @@
 POST_UNINSTALL = :
 build_triplet = @build@
 host_triplet = @host@
-bin_PROGRAMS = makeindex$(EXEEXT)
+bin_PROGRAMS = mendex$(EXEEXT)
 subdir = .
-DIST_COMMON = README $(am__configure_deps) $(dist_bin_SCRIPTS) \
-	$(dist_man1_MANS) $(srcdir)/../../build-aux/config.guess \
+DIST_COMMON = README $(am__configure_deps) $(dist_man1_MANS) \
+	$(srcdir)/../../build-aux/config.guess \
 	$(srcdir)/../../build-aux/config.sub \
 	$(srcdir)/../../build-aux/depcomp \
 	$(srcdir)/../../build-aux/install-sh \
@@ -50,11 +49,11 @@
 	../../build-aux/config.sub ../../build-aux/depcomp \
 	../../build-aux/install-sh ../../build-aux/ltmain.sh \
 	../../build-aux/missing ../../build-aux/mkinstalldirs \
-	../../build-aux/texinfo.tex ../../build-aux/ylwrap COPYING \
-	ChangeLog INSTALL NEWS
+	../../build-aux/texinfo.tex ../../build-aux/ylwrap ChangeLog
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/../../m4/kpse-common.m4 \
 	$(top_srcdir)/../../m4/kpse-kpathsea-flags.m4 \
+	$(top_srcdir)/../../m4/kpse-ptexenc-flags.m4 \
 	$(top_srcdir)/../../m4/kpse-warnings.m4 \
 	$(top_srcdir)/../../m4/libtool.m4 \
 	$(top_srcdir)/../../m4/ltoptions.m4 \
@@ -70,15 +69,29 @@
 CONFIG_HEADER = c-auto.h
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
-am__installdirs = "$(DESTDIR)$(bindir)" "$(DESTDIR)$(bindir)" \
-	"$(DESTDIR)$(man1dir)"
+am__installdirs = "$(DESTDIR)$(bindir)" "$(DESTDIR)$(man1dir)"
 PROGRAMS = $(bin_PROGRAMS)
-am_makeindex_OBJECTS = genind.$(OBJEXT) mkind.$(OBJEXT) \
-	qsort.$(OBJEXT) scanid.$(OBJEXT) scanst.$(OBJEXT) \
-	sortid.$(OBJEXT)
-makeindex_OBJECTS = $(am_makeindex_OBJECTS)
-makeindex_LDADD = $(LDADD)
+am_mendex_OBJECTS = convert.$(OBJEXT) fread.$(OBJEXT) fwrite.$(OBJEXT) \
+	kp.$(OBJEXT) main.$(OBJEXT) pageread.$(OBJEXT) sort.$(OBJEXT) \
+	styfile.$(OBJEXT)
+mendex_OBJECTS = $(am_mendex_OBJECTS)
+mendex_LDADD = $(LDADD)
 am__DEPENDENCIES_1 =
+DEFAULT_INCLUDES = -I.@am__isrc@
+depcomp = $(SHELL) $(top_srcdir)/../../build-aux/depcomp
+am__depfiles_maybe = depfiles
+am__mv = mv -f
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(mendex_SOURCES)
+DIST_SOURCES = $(mendex_SOURCES)
 am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
 am__vpath_adj = case $$p in \
     $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
@@ -100,22 +113,6 @@
 am__base_list = \
   sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
   sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
-SCRIPTS = $(dist_bin_SCRIPTS)
-DEFAULT_INCLUDES = -I.@am__isrc@
-depcomp = $(SHELL) $(top_srcdir)/../../build-aux/depcomp
-am__depfiles_maybe = depfiles
-am__mv = mv -f
-COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
-	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
-LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
-	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
-	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
-CCLD = $(CC)
-LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
-	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
-	$(LDFLAGS) -o $@
-SOURCES = $(makeindex_SOURCES)
-DIST_SOURCES = $(makeindex_SOURCES)
 man1dir = $(mandir)/man1
 NROFF = nroff
 MANS = $(dist_man1_MANS)
@@ -188,6 +185,9 @@
 PACKAGE_TARNAME = @PACKAGE_TARNAME@
 PACKAGE_VERSION = @PACKAGE_VERSION@
 PATH_SEPARATOR = @PATH_SEPARATOR@
+PTEXENC_DEPEND = @PTEXENC_DEPEND@
+PTEXENC_INCLUDES = @PTEXENC_INCLUDES@
+PTEXENC_LIBS = @PTEXENC_LIBS@
 RANLIB = @RANLIB@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
@@ -248,26 +248,30 @@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
 ACLOCAL_AMFLAGS = -I ../../m4
-INCLUDES = $(KPATHSEA_INCLUDES)
-AM_CPPFLAGS = -DUNIX -DKPATHSEA
+INCLUDES = $(KPATHSEA_INCLUDES) $(PTEXENC_INCLUDES)
+AM_CPPFLAGS = -DKPATHSEA -DKPATHSEA3
 AM_CFLAGS = $(WARNING_CFLAGS)
-dist_bin_SCRIPTS = mkindex
-makeindex_SOURCES = \
-	genind.c \
-	genind.h \
-	mkind.c \
-	mkind.h \
-	qsort.c \
-	scanid.c \
-	scanid.h \
-	scanst.c \
-	scanst.h \
-	sortid.c
+mendex_SOURCES = \
+	convert.c \
+	exkana.h \
+	exvar.h \
+	fread.c	\
+	fwrite.c \
+	kana.h \
+	kp.c \
+	kp.h \
+	ktable.h \
+	main.c \
+	mendex.h \
+	pageread.c \
+	sort.c \
+	styfile.c \
+	var.h
 
-makeindex_DEPENDENCIES = $(KPATHSEA_DEPEND)
-LDADD = $(KPATHSEA_LIBS)	
-dist_man1_MANS = makeindex.1 mkindex.1
-EXTRA_DIST = ACK CONTRIB FILES NOTES PORTING
+mendex_DEPENDENCIES = $(KPATHSEA_DEPEND) $(PTEXENC_DEPEND)
+LDADD = $(PTEXENC_LIBS) $(KPATHSEA_LIBS)
+dist_man1_MANS = mendex.1
+EXTRA_DIST = COPYRIGHT COPYRIGHT.jis ChangeLog README
 all: c-auto.h
 	$(MAKE) $(AM_MAKEFLAGS) all-am
 
@@ -367,56 +371,24 @@
 	list=`for p in $$list; do echo "$$p"; done | sed 's/$(EXEEXT)$$//'`; \
 	echo " rm -f" $$list; \
 	rm -f $$list
-makeindex$(EXEEXT): $(makeindex_OBJECTS) $(makeindex_DEPENDENCIES) 
-	@rm -f makeindex$(EXEEXT)
-	$(LINK) $(makeindex_OBJECTS) $(makeindex_LDADD) $(LIBS)
-install-dist_binSCRIPTS: $(dist_bin_SCRIPTS)
-	@$(NORMAL_INSTALL)
-	test -z "$(bindir)" || $(MKDIR_P) "$(DESTDIR)$(bindir)"
-	@list='$(dist_bin_SCRIPTS)'; test -n "$(bindir)" || list=; \
-	for p in $$list; do \
-	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
-	  if test -f "$$d$$p"; then echo "$$d$$p"; echo "$$p"; else :; fi; \
-	done | \
-	sed -e 'p;s,.*/,,;n' \
-	    -e 'h;s|.*|.|' \
-	    -e 'p;x;s,.*/,,;$(transform)' | sed 'N;N;N;s,\n, ,g' | \
-	$(AWK) 'BEGIN { files["."] = ""; dirs["."] = 1; } \
-	  { d=$$3; if (dirs[d] != 1) { print "d", d; dirs[d] = 1 } \
-	    if ($$2 == $$4) { files[d] = files[d] " " $$1; \
-	      if (++n[d] == $(am__install_max)) { \
-		print "f", d, files[d]; n[d] = 0; files[d] = "" } } \
-	    else { print "f", d "/" $$4, $$1 } } \
-	  END { for (d in files) print "f", d, files[d] }' | \
-	while read type dir files; do \
-	     if test "$$dir" = .; then dir=; else dir=/$$dir; fi; \
-	     test -z "$$files" || { \
-	       echo " $(INSTALL_SCRIPT) $$files '$(DESTDIR)$(bindir)$$dir'"; \
-	       $(INSTALL_SCRIPT) $$files "$(DESTDIR)$(bindir)$$dir" || exit $$?; \
-	     } \
-	; done
+mendex$(EXEEXT): $(mendex_OBJECTS) $(mendex_DEPENDENCIES) 
+	@rm -f mendex$(EXEEXT)
+	$(LINK) $(mendex_OBJECTS) $(mendex_LDADD) $(LIBS)
 
-uninstall-dist_binSCRIPTS:
-	@$(NORMAL_UNINSTALL)
-	@list='$(dist_bin_SCRIPTS)'; test -n "$(bindir)" || exit 0; \
-	files=`for p in $$list; do echo "$$p"; done | \
-	       sed -e 's,.*/,,;$(transform)'`; \
-	test -n "$$list" || exit 0; \
-	echo " ( cd '$(DESTDIR)$(bindir)' && rm -f" $$files ")"; \
-	cd "$(DESTDIR)$(bindir)" && rm -f $$files
-
 mostlyclean-compile:
 	-rm -f *.$(OBJEXT)
 
 distclean-compile:
 	-rm -f *.tab.c
 
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/genind.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mkind.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/qsort.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/scanid.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/scanst.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sortid.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/convert.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/fread.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/fwrite.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/kp.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/main.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pageread.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sort.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/styfile.Po@am__quote@
 
 .c.o:
 @am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
@@ -695,9 +667,9 @@
 	       exit 1; } >&2
 check-am: all-am
 check: check-am
-all-am: Makefile $(PROGRAMS) $(SCRIPTS) $(MANS) c-auto.h
+all-am: Makefile $(PROGRAMS) $(MANS) c-auto.h
 installdirs:
-	for dir in "$(DESTDIR)$(bindir)" "$(DESTDIR)$(bindir)" "$(DESTDIR)$(man1dir)"; do \
+	for dir in "$(DESTDIR)$(bindir)" "$(DESTDIR)$(man1dir)"; do \
 	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
 	done
 install: install-am
@@ -754,7 +726,7 @@
 
 install-dvi-am:
 
-install-exec-am: install-binPROGRAMS install-dist_binSCRIPTS
+install-exec-am: install-binPROGRAMS
 
 install-html: install-html-am
 
@@ -796,8 +768,7 @@
 
 ps-am:
 
-uninstall-am: uninstall-binPROGRAMS uninstall-dist_binSCRIPTS \
-	uninstall-man
+uninstall-am: uninstall-binPROGRAMS uninstall-man
 
 uninstall-man: uninstall-man1
 
@@ -810,20 +781,20 @@
 	distclean-generic distclean-hdr distclean-libtool \
 	distclean-tags distcleancheck distdir distuninstallcheck dvi \
 	dvi-am html html-am info info-am install install-am \
-	install-binPROGRAMS install-data install-data-am \
-	install-dist_binSCRIPTS install-dvi install-dvi-am \
-	install-exec install-exec-am install-html install-html-am \
-	install-info install-info-am install-man install-man1 \
-	install-pdf install-pdf-am install-ps install-ps-am \
-	install-strip installcheck installcheck-am installdirs \
-	maintainer-clean maintainer-clean-generic mostlyclean \
-	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
-	pdf pdf-am ps ps-am tags uninstall uninstall-am \
-	uninstall-binPROGRAMS uninstall-dist_binSCRIPTS uninstall-man \
+	install-binPROGRAMS install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-man1 install-pdf install-pdf-am install-ps \
+	install-ps-am install-strip installcheck installcheck-am \
+	installdirs maintainer-clean maintainer-clean-generic \
+	mostlyclean mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-binPROGRAMS uninstall-man \
 	uninstall-man1
 
 
 @KPATHSEA_RULE@
+@PTEXENC_RULE@
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
Index: ac/withenable.ac
===================================================================
--- mendexk2.6e.orig/ac/withenable.ac
+++ mendexk2.6e/ac/withenable.ac
@@ -0,0 +1,7 @@
+## texk/mendexk/ac/withenable.ac: configure.ac fragment for the TeX Live subdirectory texk/mendexk/
+dnl
+dnl Copyright (C) 2009 Peter Breitenlohner <tex-live@tug.org>
+dnl You may freely use, modify and/or distribute this file.
+dnl
+## configure options and TL libraries required for makeindexk
+KPSE_ENABLE_PROG([mendexk], [kpathsea ptexenc])
Index: pageread.c
===================================================================
--- mendexk2.6e.orig/pageread.c
+++ mendexk2.6e/pageread.c
@@ -2,11 +2,10 @@
 #include <stdlib.h>
 #include <string.h>
 
-int lastpage(filename)
 /*   checking last page   */
-char *filename;
+int lastpage(char *filename)
 {
-	int i,j,cc,num= -1;
+	int i,cc,num= -1;
 	char logfile[32],numbuff[16];
 	FILE *fp;
 
Index: kp.c
===================================================================
--- mendexk2.6e.orig/kp.c
+++ mendexk2.6e/kp.c
@@ -1,24 +1,10 @@
 /* Written by K.Asayayam  Sep. 1995 */
 #ifdef KPATHSEA
 
+#include <kpathsea/kpathsea.h>
 #include <string.h>
 #include "kp.h"
 
-/* C library functions. */
-extern char *getenv();
-
-/* Functions in kpathsea lib. */
-extern kpse_set_progname();
-extern char *kpse_cnf_get();
-extern char *kpse_path_expand();
-extern char *kpse_expand_default();
-extern char *kpse_path_search();
-extern char *find_suffix();
-extern char *concat3();
-#ifdef KPATHSEA3
-extern char *kpse_var_value();
-#endif
-
 int
 KP_init(prog)
   char *prog;
@@ -42,6 +28,8 @@
 
 #else
 
+#include <stdlib.h> /* for getenv() */
+
 /* KP_get_value(char *env,char *cnf,char *def_val)
      ARGUMENTS:
        char *env:     name of environment variable.
Index: c-auto.in
===================================================================
--- mendexk2.6e.orig/c-auto.in
+++ mendexk2.6e/c-auto.in
@@ -0,0 +1,159 @@
+/* c-auto.in.  Generated from configure.ac by autoheader.  */
+
+/* Define to 1 if the `closedir' function returns void instead of `int'. */
+#undef CLOSEDIR_VOID
+
+/* Define to 1 if you have the <assert.h> header file. */
+#undef HAVE_ASSERT_H
+
+/* Define to 1 if you have the `bcmp' function. */
+#undef HAVE_BCMP
+
+/* Define to 1 if you have the `bcopy' function. */
+#undef HAVE_BCOPY
+
+/* Define to 1 if you have the `bzero' function. */
+#undef HAVE_BZERO
+
+/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.
+   */
+#undef HAVE_DIRENT_H
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#undef HAVE_DLFCN_H
+
+/* Define to 1 if you have the <float.h> header file. */
+#undef HAVE_FLOAT_H
+
+/* Define to 1 if fseeko (and presumably ftello) exists and is declared. */
+#undef HAVE_FSEEKO
+
+/* Define to 1 if you have the `getcwd' function. */
+#undef HAVE_GETCWD
+
+/* Define to 1 if you have the `getwd' function. */
+#undef HAVE_GETWD
+
+/* Define to 1 if you have the `index' function. */
+#undef HAVE_INDEX
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#undef HAVE_INTTYPES_H
+
+/* Define to 1 if you have the <limits.h> header file. */
+#undef HAVE_LIMITS_H
+
+/* Define to 1 if you have the `memcmp' function. */
+#undef HAVE_MEMCMP
+
+/* Define to 1 if you have the `memcpy' function. */
+#undef HAVE_MEMCPY
+
+/* Define to 1 if you have the <memory.h> header file. */
+#undef HAVE_MEMORY_H
+
+/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
+#undef HAVE_NDIR_H
+
+/* Define to 1 if you are using GNU libc or otherwise have global variables
+   `program_invocation_name' and `program_invocation_short_name'. */
+#undef HAVE_PROGRAM_INVOCATION_NAME
+
+/* Define to 1 if you have the `putenv' function. */
+#undef HAVE_PUTENV
+
+/* Define to 1 if you have the <pwd.h> header file. */
+#undef HAVE_PWD_H
+
+/* Define to 1 if you have the `rindex' function. */
+#undef HAVE_RINDEX
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#undef HAVE_STDINT_H
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#undef HAVE_STDLIB_H
+
+/* Define to 1 if you have the `strcasecmp' function. */
+#undef HAVE_STRCASECMP
+
+/* Define to 1 if you have the `strchr' function. */
+#undef HAVE_STRCHR
+
+/* Define to 1 if you have the <strings.h> header file. */
+#undef HAVE_STRINGS_H
+
+/* Define to 1 if you have the <string.h> header file. */
+#undef HAVE_STRING_H
+
+/* Define to 1 if you have the `strrchr' function. */
+#undef HAVE_STRRCHR
+
+/* Define to 1 if you have the `strstr' function. */
+#undef HAVE_STRSTR
+
+/* Define to 1 if you have the `strtol' function. */
+#undef HAVE_STRTOL
+
+/* Define to 1 if `st_mtim' is member of `struct stat'. */
+#undef HAVE_STRUCT_STAT_ST_MTIM
+
+/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
+   */
+#undef HAVE_SYS_DIR_H
+
+/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.
+   */
+#undef HAVE_SYS_NDIR_H
+
+/* Define to 1 if you have the <sys/param.h> header file. */
+#undef HAVE_SYS_PARAM_H
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#undef HAVE_SYS_STAT_H
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#undef HAVE_SYS_TYPES_H
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#undef HAVE_UNISTD_H
+
+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+#undef LT_OBJDIR
+
+/* Define to the address where bug reports for this package should be sent. */
+#undef PACKAGE_BUGREPORT
+
+/* Define to the full name of this package. */
+#undef PACKAGE_NAME
+
+/* Define to the full name and version of this package. */
+#undef PACKAGE_STRING
+
+/* Define to the one symbol short name of this package. */
+#undef PACKAGE_TARNAME
+
+/* Define to the version of this package. */
+#undef PACKAGE_VERSION
+
+/* Define to 1 if you have the ANSI C header files. */
+#undef STDC_HEADERS
+
+/* Number of bits in a file offset, on hosts where this is settable. */
+#undef _FILE_OFFSET_BITS
+
+/* Define to 1 to make fseeko visible on some hosts (e.g. glibc 2.2). */
+#undef _LARGEFILE_SOURCE
+
+/* Define for large files, on AIX-style hosts. */
+#undef _LARGE_FILES
+
+/* Define to empty if `const' does not conform to ANSI C. */
+#undef const
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
+#undef inline
+#endif
Index: styfile.c
===================================================================
--- mendexk2.6e.orig/styfile.c
+++ mendexk2.6e/styfile.c
@@ -2,6 +2,10 @@
 #include <stdlib.h>
 #include <string.h>
 
+#include <kpathsea/config.h>
+#include <ptexenc/ptexenc.h>
+#include "mendex.h"
+
 #include "exvar.h"
 
 #ifdef KPATHSEA
@@ -11,17 +15,24 @@
 
 FILE *fp;
 
-int styread(filename)
+void convline(char *buff1, int start, char *buff2);
+int scompare(char *buff1, char *buff2);
+int getparam(char *buff, char *paraname, char *param);
+int getparachar(char *buff, char *paraname, char *param);
+size_t sstrlen(const char *buff);
+int sstrcmp(const char *s1, const char *s2);
+int sstrncmp(const char *s1, const char *s2, size_t len);
+
 /*   read style file   */
-char *filename;
+void styread(char *filename)
 {
-	int i,j,k,cc;
+	int i,cc;
 	char buff[4096];
 
 #ifdef KPATHSEA
 	filename = KP_find_file(&kp_ist,filename);
 #endif
-	fp=fopen(filename,"r");
+	fp=nkf_open(filename,"r");
 	if (fp==NULL) {
 		fprintf(stderr,"%s does not exist.\n",filename);
 		exit(0);
@@ -112,14 +123,13 @@
 		if (getparam(buff,"page_precedence",page_precedence)) continue;
 		if (getparam(buff,"character_order",character_order)) continue;
 	}
+	nkf_close(fp);
 }
 
-int convline(buff1,start,buff2)
 /*   analize string parameter of style file   */
-char *buff1,*buff2;
-int start;
+void convline(char *buff1, int start, char *buff2)
 {
-	int i,j,k,cc;
+	int i,j,cc;
 
 	for (i=start,j=cc=0;;i++) {
 		if (buff1[i]=='\"') {
@@ -161,11 +171,10 @@
 	}
 }
 
-int scompare(buff1,buff2)
 /*   compare strings   */
-char *buff1,*buff2;
+int scompare(char *buff1, char *buff2)
 {
-	int i,j,k,cc;
+	int i;
 
 	if (sstrlen(buff1) == sstrlen(buff2)) {
 		if (sstrcmp(buff1,buff2) == 0) {
@@ -187,9 +196,8 @@
 	return -1;
 }
 
-int getparam(buff,paraname,param)
 /*   get string of style patameter   */
-char *buff,*paraname,*param;
+int getparam(char *buff, char *paraname, char *param)
 {
 	int cc;
 
@@ -201,9 +209,8 @@
 	return 0;
 }
 
-int getparachar(buff,paraname,param)
 /*   get character of style parameter   */
-char *buff,*paraname,*param;
+int getparachar(char *buff, char *paraname, char *param)
 {
 	int j,cc;
 
@@ -226,30 +233,22 @@
 	return 0;
 }
 
-int sstrlen(buff)
-char *buff;
+size_t sstrlen(const char *s)
 {
-	int i;
-
-	if (buff==NULL) return 0;
-
-	for (i=0;;i++) {
-		if (buff[i]=='\0') return i;
-	}
+	if (s == NULL) return 0;
+	return strlen(s);
 }
 
-int sstrncmp(buff1,buff2,len)
-char *buff1,*buff2;
-int len;
+int sstrcmp(const char *s1, const char *s2)
 {
-	int i;
+	if (s1 == NULL) return -1;
+	if (s2 == NULL) return 1;
+	return strcmp(s1, s2);
+}
 
-	if (buff1==NULL) return -1;
-	if (buff2==NULL) return 1;
-
-	for (i=0;i<len;i++) {
-		if ((buff1[i]=='\0')&&(buff2[i]=='\0')) return 0;
-		if (buff1[i]!=buff2[i]) return buff1[i]-buff2[i];
-	}
-	return 0;
+int sstrncmp(const char *s1, const char *s2, size_t len)
+{
+	if (s1 == NULL) return -1;
+	if (s2 == NULL) return 1;
+	return strncmp(s1, s2, len);
 }
Index: convert.c
===================================================================
--- mendexk2.6e.orig/convert.c
+++ mendexk2.6e/convert.c
@@ -1,7 +1,12 @@
- #include <stdio.h>
+#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
+#include <kpathsea/config.h>
+#include <kpathsea/lib.h>
+#include <ptexenc/ptexenc.h>
+#include "mendex.h"
+
 #include "exkana.h"
 #include "ktable.h"
 #include "exvar.h"
@@ -11,9 +16,6 @@
 extern KpathseaSupportInfo kp_dict;
 #endif
 
-extern char *mfgets();
-extern int convputs();
-
 struct dictionary{
 unsigned char dic[2][50];
 };
@@ -21,10 +23,12 @@
 struct dictionary *dictable,*envdic;
 int dlines=0,elines=0;
 
-int initkanatable()
+int dicvalread(char *filename, struct dictionary *dicval, int line);
+
 /*   initialize kana table   */
+void initkanatable(void)
 {
-	int i,j,cc;
+	int i,cc;
 
 	for (i=0xa4a1;i<=0xa4f3;i++) {
 		cc=i-0xa4a1;
@@ -40,13 +44,13 @@
 	}
 	katakana[(i-0xa5a1)*2]=0;
 
-	akasatana=strdup(AKASATANA);
+	akasatana=xstrdup(AKASATANA);
 	for (i=0;;i++) {
 		if (akasatana[i*2]==0) break;
 		akasatana[i*2]++;
 	}
 
-	aiueo=strdup(AIUEO);
+	aiueo=xstrdup(AIUEO);
 	for (i=0;;i++) {
 		if (aiueo[i*2]==0) break;
 		aiueo[i*2]++;
@@ -55,11 +59,10 @@
 	strcpy(atama,akasatana);
 }
 
-int dicread(filename)
 /*   get dictionary   */
-char *filename;
+int dicread(char *filename)
 {
-	int i,j,k,l,ecount=0;
+	int i,ecount=0;
 	char *envfile,buff[4096];
 	FILE *fp;
 
@@ -67,28 +70,24 @@
 #ifdef KPATHSEA
 		filename = KP_find_file(&kp_dict,filename);
 #endif
-		fp=fopen(filename,"r");
+		fp=nkf_open(filename,"r");
 		if (fp==NULL) {
-			fprintf(stderr,"Warning: Couldn't find dictionary file %s.\n",filename);
-			if (efp!=stderr) fprintf(efp,"Warning: Couldn't find dictionary file %s.\n",filename);
-			warn++;
+			warn_printf(efp,"Warning: Couldn't find dictionary file %s.\n",filename);
 			goto ENV;
 		}
-		if (verb!=0) fprintf(stderr,"Scanning dictionary file %s.",filename);
-		if (efp!=stderr) fprintf(efp,"Scanning dictionary file %s.",filename);
+		verb_printf(efp,"Scanning dictionary file %s.",filename);
 
 		for (i=0;;i++) {
 			if (mfgets(buff,4095,fp)==NULL) break;
 			if ((buff[0]=='\n')||(buff[0]=='\0')) i--;
 		}
-		fclose(fp);
+		nkf_close(fp);
 
 		dictable=(struct dictionary *)malloc(sizeof(struct dictionary)*i);
 
 		dlines=dicvalread(filename,dictable,i);
 
-		if (verb!=0) fprintf(stderr,"...done.\n");
-		if (efp!=stderr) fprintf(efp,"...done.\n");
+		verb_printf(efp,"...done.\n");
 	}
 
 ENV:
@@ -105,47 +104,38 @@
 #ifdef KPATHSEA
 		envfile = KP_find_file(&kp_dict,envfile);
 #endif
-		fp=fopen(envfile,"r");
+		fp=nkf_open(envfile,"r");
 		if (fp==NULL) {
-			fprintf(stderr,"Warning: Couldn't find environment dictionary file %s.\n",envfile);
-			if (efp!=stderr) fprintf(efp,"Warning: Couldn't find environment dictionary file %s.\n",envfile);
-			warn++;
+			warn_printf(efp,"Warning: Couldn't find environment dictionary file %s.\n",envfile);
 			return ecount;
 		}
+		verb_printf(efp,"Scanning environment dictionary file %s.",envfile);
 
-		if (verb!=0) fprintf(stderr,"Scanning environment dictionary file %s.",envfile);
-		if (efp!=stderr) fprintf(efp,"Scanning environment dictionary file %s.",envfile);
-
 		for (i=0;;i++) {
 			if (mfgets(buff,255,fp)==NULL) break;
 			if ((buff[0]=='\n')||(buff[0]=='\0')) i--;
 		}
-		fclose(fp);
+		nkf_close(fp);
 
 		envdic=(struct dictionary *)malloc(sizeof(struct dictionary)*i);
 
 		elines=dicvalread(envfile,envdic,i);
 
-		if (verb!=0) fprintf(stderr,"...done.\n");
-		if (efp!=stderr) fprintf(efp,"...done.\n");
+		verb_printf(efp,"...done.\n");
 	}
 }
 
-int dicvalread(filename,dicval,line)
 /*   read dictionary file   */
-char *filename;
-struct dictionary *dicval;
-int line;
+int dicvalread(char *filename, struct dictionary *dicval, int line)
 {
-	int i,j,k,l,cc;
+	int i,j,k;
 	unsigned char buff[256];
 	FILE *fp;
 
 	int dcomp();
 
-	fp=fopen(filename,"r");
+	fp=nkf_open(filename,"r");
 	for (i=0;i<line;i++) {
-READING:
 		if (mfgets(buff,255,fp)==NULL) break;
 		if ((buff[0]=='\n')||(buff[0]=='\0')) {
 			i--;
@@ -174,17 +164,16 @@
 		strcpy(dicval[i].dic[1],buff);
 	}
 
-	fclose(fp);
+	nkf_close(fp);
 
 	qsort(dicval,i,sizeof(struct dictionary),dcomp);
 	return(i);
 }
 
-int dcomp(buff1,buff2)
 /*   comp-function of dictionary sorting   */
-struct dictionary *buff1,*buff2;
+int dcomp(struct dictionary *buff1, struct dictionary *buff2)
 {
-	int i,j;
+	int i;
 
 	for (i=0;i<50;i++) {
 		if (((*buff1).dic[0][i]=='\0')&&((*buff2).dic[0][i]=='\0')) return 0;
@@ -196,12 +185,10 @@
 	return 0;
 }
 
-int convert(buff1,buff2)
 /*   convert to capital-hiragana character   */
-unsigned char *buff1,*buff2;
+int convert(unsigned char *buff1, unsigned char *buff2)
 {
-	int i=0,j=0,k,l,cc;
-	unsigned char str[2];
+	int i=0,j=0,k,l;
 	char errbuff[4096];
 
 	while(1) {
@@ -235,8 +222,8 @@
 					}
 				}
 				sprintf(errbuff,"\nError: %s is bad katakana ",&buff1[i]);
-				convputs(errbuff,efp);
-				if (efp!=stderr) convputs(errbuff,stderr);
+				fputs(errbuff,efp);
+				if (efp!=stderr) fputs(errbuff,stderr);
 				return -1;
 MATCH1:
 				i+=2;
@@ -252,8 +239,8 @@
 					}
 				}
 				sprintf(errbuff,"\nError: %s is bad hiragana ",&buff1[i]);
-				convputs(errbuff,efp);
-				if (efp!=stderr) convputs(errbuff,stderr);
+				fputs(errbuff,efp);
+				if (efp!=stderr) fputs(errbuff,stderr);
 				return -1;
 MATCH2:
 				i+=2;
@@ -273,8 +260,8 @@
 					}
 				}
 				sprintf(errbuff,"\nError: %s is Illegal line ",buff1);
-				convputs(errbuff,efp);
-				if (efp!=stderr) convputs(errbuff,stderr);
+				fputs(errbuff,efp);
+				if (efp!=stderr) fputs(errbuff,stderr);
 				return -1;
 MATCH3:
 				i+=2;
@@ -328,8 +315,8 @@
 						}
 						else {
 							sprintf(errbuff,"\nError: %s is no entry in dictionary file ",&buff1[i]);
-							convputs(errbuff,efp);
-							if (efp!=stderr) convputs(errbuff,stderr);
+							fputs(errbuff,efp);
+							if (efp!=stderr) fputs(errbuff,stderr);
 							return -1;
 						}
 					}
@@ -340,11 +327,9 @@
 	return 0;
 }
 
-int pnumconv(page,attr)
-char *page;
-int attr;
+int pnumconv(char *page, int attr)
 {
-	int i,j,cc=0;
+	int i,cc=0;
 
 	switch (page_precedence[attr]) {
 	case 'a':
@@ -526,52 +511,7 @@
 	return cc;
 }
 
-int nbyte(str,n)
-unsigned char *str;
-int n;
+int nbyte(unsigned char *str, int n)
 {
 	return (unsigned int)str[n];
 }
-
-int JIStoSJIS(c)
-int c;
-{
-    int high,low;
-    int nh,nl;
-
-    high = (c>>8) & 0xff;
-    low = c & 0xff;
-    nh = ((high-0x21)>>1) + 0x81;
-    if (nh>0x9f)
-    nh += 0x40;
-    if (high & 1) {
-        nl = low + 0x1f;
-        if (low>0x5f)
-        nl++;
-    }
-    else
-        nl = low + 0x7e;
-    if (((nh >= 0x81 && nh <= 0x9f) || (nh >= 0xe0 && nh <= 0xfc))
-    && (nl >= 0x40 && nl <= 0xfc && nl != 0x7f))
-        return (nh<<8) | nl;
-    else
-        return 0x813f;
-}
-
-int SJIStoJIS(c)
-int c;
-{
-    int byte1,byte2;
-
-    byte1 = (c>>8) & 0xff;
-    byte2 = c & 0xff;
-    byte1 -= ( byte1>=0xa0 ) ? 0xc1 : 0x81;
-    c = ((byte1<<1) + 0x21)<<8;
-    if( byte2>=0x9f ) {
-        c += 0x0100;
-        c |= (byte2 - 0x7e) & 0xff;
-    } else {
-        c |= (byte2 - ((byte2<=0x7e) ? 0x1f : 0x20 )) & 0xff;
-    }
-    return c;
-}
Index: fread.c
===================================================================
--- mendexk2.6e.orig/fread.c
+++ mendexk2.6e/fread.c
@@ -2,21 +2,23 @@
 #include <stdlib.h>
 #include <string.h>
 
+#include <kpathsea/config.h>
+#include <ptexenc/ptexenc.h>
+#include "mendex.h"
+
 #include "exkana.h"
 #include "exvar.h"
 
 #define BUFSIZE 65535
 
-char *mfgets();
-extern char *convcode();
+int getestr(unsigned char *buff, unsigned char *estr);
+void chkpageattr(struct page *p);
 
-int idxread(filename,start)
 /*   read idx file   */
-char *filename;
-int start;
+int idxread(char *filename, int start)
 {
-	int i,j,k,l,m,n,cc,indent,wflg,flg,bflg=0,nest,esc,quo,eflg=0,pacc,preject;
-	unsigned char buff[BUFSIZE],wbuff[BUFSIZE],estr[256],table[BUFSIZE],tbuff[256],*tmp1,*tmp2;
+	int i,j,k,l,m,n,cc,indent,wflg,flg=0,bflg=0,nest,esc,quo,eflg=0,pacc,preject;
+	unsigned char buff[BUFSIZE],wbuff[BUFSIZE],estr[256],table[BUFSIZE],*tmp1,*tmp2;
 	FILE *fp;
 
 	pacc=acc;
@@ -24,26 +26,20 @@
 
 	if (filename==NULL) {
 		fp=stdin;
-		if (verb!=0) fputs("Scanning input file stdin.",stderr);
-		if (efp!=stderr) fputs("Scanning input file stdin.",efp);
+		verb_printf(efp, "Scanning input file stdin.");
 	}
 	else {
-		fp=fopen(filename,"r");
+		fp=nkf_open(filename,"r");
 		if (fp==NULL) {
 			sprintf(buff,"%s.idx",filename);
-			fp=fopen(buff,"r");
+			fp=nkf_open(buff,"r");
 			if (fp==NULL) {
-				if (verb!=0)
-					fprintf(stderr,"Warning: Couldn't find input file %s.\n",filename);
-				if (efp!=stderr)
-					fprintf(efp,"Warning: Couldn't find input file %s.\n",filename);
-				warn++;
+				warn_printf(efp,"Warning: Couldn't find input file %s.\n",filename);
 				return 1;
 			}
 			else strcpy(filename,buff);
 		}
-		if (verb!=0) fprintf(stderr,"Scanning input file %s.",filename);
-		if (efp!=stderr) fprintf(efp,"Scanning input file %s.",filename);
+		verb_printf(efp,"Scanning input file %s.",filename);
 	}
 
 	for (i=start,n=1;;i++,n++) {
@@ -78,10 +74,7 @@
 
 		for (;;j++,k++) {
 			if (buff[j]=='\n' || buff[j]=='\0') {
-				if (verb!=0)
-					fprintf(stderr,"\nWarning: Incomplete first argument in %s, line %d.",filename,ind[i].lnum);
-				if (efp!=stderr)
-					 fprintf(efp,"\nWarning: Incomplete first argument in %s, line %d.",filename,ind[i].lnum);
+				verb_printf(efp,"\nWarning: Incomplete first argument in %s, line %d.",filename,ind[i].lnum);
 				warn++;
 				n++;
 				goto LOOP;
@@ -185,10 +178,7 @@
 								indent--;
 							}
 							else {
-								if (verb!=0)
-									fprintf(stderr,"\nWarning: Illegal null field in %s, line %d.",filename,ind[i].lnum);
-								if (efp!=stderr)
-									fprintf(efp,"\nWarning: Illegal null field in %s, line %d.",filename,ind[i].lnum);
+								verb_printf(efp,"\nWarning: Illegal null field in %s, line %d.",filename,ind[i].lnum);
 								warn++;
 								n++;
 								goto LOOP;
@@ -277,10 +267,7 @@
 			ind[0].p=(struct page *)malloc(sizeof(struct page)*16);
 			for (;buff[j]!=arg_open && buff[j]!='\n' && buff[j]!='\0';j++);
 			if (buff[j]=='\n' || buff[j]=='\0') {
-				if (verb!=0)
-					fprintf(stderr,"\nWarning: Missing second argument in %s, line %d.",filename,ind[i].lnum);
-				if (efp!=stderr)
-					fprintf(efp,"\nWarning: Missing second argument in %s, line %d.",filename,ind[i].lnum);
+				verb_printf(efp,"\nWarning: Missing second argument in %s, line %d.",filename,ind[i].lnum);
 				acc--;
 				reject++;
 				warn++;
@@ -290,10 +277,7 @@
 			j++;
 			for (k=nest=0;;j++,k++) {
 				if (buff[j]=='\n' || buff[j]=='\0') {
-					if (verb!=0)
-						fprintf(stderr,"\nWarning: Incomplete second argument in %s, line %d.",filename,ind[i].lnum);
-					if (efp!=stderr)
-						fprintf(efp,"\nWarning: Incomplete second argument in %s, line %d.",filename,ind[i].lnum);
+					verb_printf(efp,"\nWarning: Incomplete second argument in %s, line %d.",filename,ind[i].lnum);
 					acc--;
 					reject++;
 					warn++;
@@ -346,10 +330,7 @@
 						if (ind[l].org[m]!=NULL) tmp2=ind[l].org[m];
 						else tmp2=ind[i].idx[m];
 
-						if (verb!=0)
-							fprintf(stderr,"\nWarning: Sort key \"%s\" is different from previous key \"%s\" for same index \"%s\" in %s, line %d.",convcode(tmp1),convcode(tmp2),convcode(ind[i].idx[m]),filename,ind[i].lnum);
-						if (efp!=stderr)
-							fprintf(efp,"\nWarning: Sort key \"%s\" is different from previous key \"%s\" for same index \"%s\" in %s, line %d.",convcode(tmp1),convcode(tmp2),convcode(ind[i].idx[m]),filename,ind[i].lnum);
+						verb_printf(efp,"\nWarning: Sort key \"%s\" is different from previous key \"%s\" for same index \"%s\" in %s, line %d.",tmp1, tmp2, ind[i].idx[m], filename,ind[i].lnum);
 						warn++;
 						flg=0;
 						break;
@@ -367,10 +348,7 @@
 				i--;
 				for (;buff[j]!=arg_open && buff[j]!='\n' && buff[j]!='\0';j++);
 				if (buff[j]=='\n' || buff[j]=='\0') {
-					if (verb!=0)
-						fprintf(stderr,"\nWarning: Missing second argument in %s, line %d.",filename,ind[i].lnum);
-					if (efp!=stderr)
-						fprintf(efp,"\nWarning: Missing second argument in %s, line %d.",filename,ind[i].lnum);
+					verb_printf(efp,"\nWarning: Missing second argument in %s, line %d.",filename,ind[i].lnum);
 					acc--;
 					reject++;
 					warn++;
@@ -381,10 +359,7 @@
 				j++;
 				for (k=nest=0;;j++,k++) {
 					if (buff[j]=='\n' || buff[j]=='\0') {
-						if (verb!=0)
-							fprintf(stderr,"\nWarning: Incomplete second argument in %s, line %d.",filename,ind[i].lnum);
-						if (efp!=stderr)
-							fprintf(efp,"\nWarning: Incomplete second argument in %s, line %d.",filename,ind[i].lnum);
+						verb_printf(efp,"\nWarning: Incomplete second argument in %s, line %d.",filename,ind[i].lnum);
 						warn++;
 						n++;
 						i++;
@@ -429,10 +404,7 @@
 				ind[i].p=(struct page *)malloc(sizeof(struct page)*16);
 				for (;buff[j]!=arg_open && buff[j]!='\n' && buff[j]!='\0';j++);
 				if (buff[j]=='\n' || buff[j]=='\0') {
-					if (verb!=0)
-						fprintf(stderr,"\nWarning: Missing second argument in %s, line %d.",filename,ind[i].lnum);
-					if (efp!=stderr)
-						fprintf(efp,"\nWarning: Missing second argument in %s, line %d.",filename,ind[i].lnum);
+					verb_printf(efp,"\nWarning: Missing second argument in %s, line %d.",filename,ind[i].lnum);
 					acc--;
 					reject++;
 					warn++;
@@ -442,10 +414,7 @@
 				j++;
 				for (k=nest=0;;j++,k++) {
 					if (buff[j]=='\n' || buff[j]=='\0') {
-						if (verb!=0)
-							fprintf(stderr,"\nWarning: Incomplete second argument in %s, line %d.",filename,ind[i].lnum);
-						if (efp!=stderr)
-							fprintf(efp,"\nWarning: Incomplete second argument in %s, line %d.",filename,ind[i].lnum);
+						verb_printf(efp,"\nWarning: Incomplete second argument in %s, line %d.",filename,ind[i].lnum);
 						acc--;
 						reject++;
 						warn++;
@@ -477,21 +446,16 @@
 		}
 	}
 	lines=i;
+	if (filename != NULL) nkf_close(fp);
 
-	if (verb!=0) {
-		fprintf(stderr,"...done (%d entries accepted, %d rejected).\n",acc-pacc, reject-preject);
-	}
-	if (efp!=stderr) {
-		fprintf(efp,"...done (%d entries accepted, %d rejected).\n",acc-pacc, reject-preject);
-	}
+	verb_printf(efp,"...done (%d entries accepted, %d rejected).\n",acc-pacc, reject-preject);
 	return eflg;
 }
 
-int getestr(buff,estr)
 /*   pic up encap string   */
-unsigned char *buff,*estr;
+int getestr(unsigned char *buff, unsigned char *estr)
 {
-	int i,j,cc,nest=0;
+	int i,nest=0;
 
 	for (i=0;i<strlen(buff);i++) {
 		if (buff[i]==encap) {
@@ -522,20 +486,8 @@
 	return -1;
 }
 
-int sstrcmp(buff1,buff2)
-char *buff1,*buff2;
+void chkpageattr(struct page *p)
 {
-	int i;
-
-	for (i=0;;i++) {
-		if (buff1[i]=='\0' && buff2[i]=='\0') return 0;
-		if (buff1[i]!=buff2[i]) return 1;
-	}
-}
-
-chkpageattr(p)
-struct page *p;
-{
 	int i,j,cc=0;
 
 	for (i=0;i<strlen(p->page);i++) {
@@ -596,53 +548,15 @@
 	if (cc<2) p->attr[++cc]= -1;
 }
 
-char *mfgets(buf,byte,fp)
-char *buf;
-int byte;
-FILE *fp;
+char *mfgets(char *buf, int byte, FILE *fp)
 {
-	int i,cc,cc2,cc3,jflag=0;
+	int c, len;
 
-	for (i=0;i<byte;i++) {
-		cc=fgetc(fp);
-		if (cc==EOF) {
-			if (i==0) return NULL;
-			else break;
-		}
-		else if (cc=='\n') {
-			buf[i++]=cc;
-			break;
-		}
-		else if (cc>=0x80) {
-			cc2=fgetc(fp);
-			if (kanji==Sjis) {
-				cc=SJIStoJIS((cc<<8)+cc2)+0x8080;
-			}
-			else {
-				cc=(cc<<8)+cc2;
-			}
-			buf[i++]=(cc>>8)&0xff;
-			buf[i]=cc&0xff;
-		}
-		else if (cc==0x1b) {
-			cc2=fgetc(fp);
-			cc3=fgetc(fp);
-			if (cc2==0x24 && (cc3==0x42 || cc3==0x40))
-				jflag++;
-			else if (cc2==0x28 && (cc3==0x42 || cc3==0x4a))
-				if (jflag>0) jflag--;
-			else {
-				buf[i++]=cc;
-				buf[i++]=cc2;
-				buf[i++]=cc3;
-			}
-			i--;
-		}
-		else if (jflag) {
-			buf[i]=cc+0x80;
-		}
-		else buf[i]=cc;
+	if ((len = input_line2(fp, buf, 0, byte, &c)) == 0) return NULL;
+	if (c == '\n' || c == '\r') {
+		if (len+1 < byte) strcat(buf+len, "\n");
+		else ungetc(c, fp);
 	}
-	buf[i]='\0';
+	if (c == EOF) return NULL;
 	return buf;
 }
Index: configure.ac
===================================================================
--- mendexk2.6e.orig/configure.ac
+++ mendexk2.6e/configure.ac
@@ -0,0 +1,28 @@
+dnl Process this file with autoconf to produce a configure script.
+dnl
+dnl   Copyright (C) 2009 Peter Breitenlohner <tex-live@tug.org>
+dnl
+dnl   This file is free software; the copyright holder
+dnl   gives unlimited permission to copy and/or distribute it,
+dnl   with or without modifications, as long as this notice is preserved.
+dnl
+AC_INIT([mendex for TeX Live], [2.6f])
+AC_PREREQ([2.63])
+AC_CONFIG_SRCDIR([main.c])
+AC_CONFIG_AUX_DIR([../../build-aux])
+AC_CONFIG_MACRO_DIR([../../m4])
+
+dnl Common code for all programs using libkpathsea.
+KPSE_COMMON([mendexk], [no-define])
+
+AC_CONFIG_HEADERS([c-auto.h:c-auto.in])
+
+AC_CHECK_HEADERS([strings.h])
+AC_CHECK_FUNCS([])
+
+KPSE_KPATHSEA_FLAGS
+KPSE_PTEXENC_FLAGS
+
+AC_CONFIG_FILES([Makefile])
+
+AC_OUTPUT
Index: main.c
===================================================================
--- mendexk2.6e.orig/main.c
+++ mendexk2.6e/main.c
@@ -2,6 +2,10 @@
 #include <stdlib.h>
 #include <string.h>
 
+#include <kpathsea/config.h>
+#include <ptexenc/ptexenc.h>
+#include "mendex.h"
+
 #include "kana.h"
 #include "var.h"
 
@@ -24,15 +28,12 @@
 
 #define VERSION "version 2.6f [14-Aug-2009]"
 
-main(argc,argv)
-int argc;
-char **argv;
+int main(int argc, char **argv)
 {
-	int i,j,k,cc,dd,startpagenum,ecount=0;
-	char buff[256],*envbuff;
-	FILE *fp;
-	char *convcode();
+	int i,j,cc=0,startpagenum=-1,ecount=0;
+	char *envbuff;
 
+        set_enc_string(NULL, "EUC");
 #ifdef KPATHSEA
 	KP_init(argv[0]);
 	kp_ist.var_name = "INDEXSTYLE";
@@ -147,19 +148,23 @@
 				break;
 
 			case 'E':
-				kanji=Euc;
+				set_enc_string("EUC", NULL);
 				break;
 
 			case 'J':
-				kanji=Jis;
+				set_enc_string("JIS", NULL);
 				break;
 
 			case 'S':
-				kanji=Sjis;
+				set_enc_string("SJIS", NULL);
 				break;
 
+			case 'U':
+				set_enc_string("UTF8", NULL);
+				break;
+
 			default:
-				fprintf(stderr,"mendex - Japanese index processor, %s.\n",VERSION);
+				fprintf(stderr,"mendex - Japanese index processor, %s (%s).\n",VERSION, get_enc_string());
 				fprintf(stderr," Copyright 2009 ASCII MEDIA WORKS.(ptex-staff@ml.asciimw.jp)\n");
 				fprintf(stderr,"usage:\n");
 				fprintf(stderr,"%% mendex [-ilqrcg] [-s sty] [-d dic] [-o ind] [-t log] [-p no] [idx0 idx1 ...]\n");
@@ -169,7 +174,7 @@
 				fprintf(stderr,"-q      quiet mode.\n");
 				fprintf(stderr,"-r      disable implicit page formation.\n");
 				fprintf(stderr,"-c      compress blanks. (ignore leading and trailing blanks.)\n");
-				fprintf(stderr,"-g      make Japanese index head <%s>.\n",convcode(AKASATANA));
+				fprintf(stderr,"-g      make Japanese index head <%s>.\n", AKASATANA);
 				fprintf(stderr,"-f      force to output kanji.\n");
 				fprintf(stderr,"-s sty  take sty as style file.\n");
 				fprintf(stderr,"-d dic  take dic as dictionary file.\n");
@@ -179,6 +184,7 @@
 				fprintf(stderr,"-E      EUC mode.\n");
 				fprintf(stderr,"-J      JIS mode.\n");
 				fprintf(stderr,"-S      ShiftJIS mode.\n");
+				fprintf(stderr,"-U      UTF-8 mode.\n");
 				fprintf(stderr,"idx...  input files.\n");
 				exit(0);
 				break;
@@ -247,12 +253,13 @@
 	else efp=fopen(logfile,"w");
 
 	if (strcmp(argv[0],"makeindex")==0) {
-		if (verb!=0) fprintf(stderr,"This is Not `MAKEINDEX\', But `MENDEX\' %s.\n",VERSION);
+		verb_printf(efp,"This is Not `MAKEINDEX\', But `MENDEX\' %s (%s).\n",
+			    VERSION, get_enc_string());
 	}
 	else {
-		if (verb!=0) fprintf(stderr,"This is mendex %s.\n",VERSION);
+		verb_printf(efp,"This is mendex %s (%s).\n",
+			    VERSION, get_enc_string());
 	}
-	if (efp!=stderr) fprintf(efp,"This is mendex %s.\n",VERSION);
 
 /*   init kanatable   */
 
@@ -298,64 +305,36 @@
 	if (fsti==1) {
 		ecount+=idxread(NULL,lines);
 	}
-	if (verb!=0) {
-		fprintf(stderr,"%d entries accepted, %d rejected.\n",acc,reject);
-	}
-	if (efp!=stderr) {
-		fprintf(efp,"%d entries accepted, %d rejected.\n",acc,reject);
-	}
+	verb_printf(efp,"%d entries accepted, %d rejected.\n",acc,reject);
 
 	if (ecount!=0) {
-		if (verb!=0) {
-			fprintf(stderr,"%d errors, written in %s.\n",ecount,logfile);
-		}
-		if (efp!=stderr) {
-			fprintf(efp,"%d errors.\n",ecount);
-		}
+		verb_printf(efp,"%d errors, written in %s.\n",ecount,logfile);
 		lines=0;
 	}
 	if (lines==0) {
-		if (verb!=0) {
-			fprintf(stderr,"Nothing written in output file.\n");
-		}
-		if (efp!=stderr) {
-			fprintf(efp,"Nothing written in output file.\n");
-			fclose(efp);
-		}
+		verb_printf(efp,"Nothing written in output file.\n");
+		if (efp!=stderr) fclose(efp);
 		exit(-1);
 	}
 
 /*   sort index   */
 
-	if (verb!=0) fprintf(stderr,"Sorting index.");
-	if (efp!=stderr) fprintf(efp,"Sorting index.");
+	verb_printf(efp,"Sorting index.");
 
 	scount=0;
 	wsort(ind,lines);
 
-	if (verb!=0) {
-		fprintf(stderr,"...done(%d comparisons).\n",scount);
-	}
-	if (efp!=stderr) {
-		fprintf(efp,"...done(%d comparisons).\n",scount);
-	}
+	verb_printf(efp,"...done(%d comparisons).\n",scount);
 
 /*   sort pages   */
 
-	if (verb!=0) fprintf(stderr,"Sorting pages.");
-	if (efp!=stderr) fprintf(efp,"Sorting pages.");
+	verb_printf(efp,"Sorting pages.");
 
 	scount=0;
 	pagesort(ind,lines);
 
+	verb_printf(efp,"...done(%d comparisons).\n",scount);
 
-	if (verb!=0) {
-		fprintf(stderr,"...done(%d comparisons).\n",scount);
-	}
-	if (efp!=stderr) {
-		fprintf(efp,"...done(%d comparisons).\n",scount);
-	}
-
 /*   get last page   */
 
 	if ((fpage>1)&&(idxcount-fsti>0)) cc=lastpage(idxfile[0]);
@@ -381,31 +360,17 @@
 
 /*   write indfile   */
 
-	if (verb!=0) fprintf(stderr,"Making index file.");
-	if (efp!=stderr) fprintf(efp,"Making index file.");
+	verb_printf(efp,"Making index file.");
 
 	indwrite(indfile,ind,startpagenum);
 
-	if (verb!=0) fprintf(stderr,"...done.\n");
-	if (efp!=stderr) fprintf(efp,"...done.\n");
+	verb_printf(efp,"...done.\n");
 
 	if (idxcount-fsti==0) strcpy(indfile,"stdout");
 
-	if (verb!=0) {
-		fprintf(stderr,"%d warnings, written in %s.\n",warn,logfile);
-		fprintf(stderr,"Output written in %s.\n",indfile);
-	}
-	if (efp!=stderr) {
-		fprintf(efp,"%d warnings, written in %s.\n",warn,logfile);
-		fprintf(efp,"Output written in %s.\n",indfile);
-		fclose(efp);
-	}
+	verb_printf(efp,"%d warnings, written in %s.\n",warn,logfile);
+	verb_printf(efp,"Output written in %s.\n",indfile);
+	if (efp!=stderr) fclose(efp);
 
 	exit(0);
 }
-
-Fprintf(buff)
-char *buff;
-{
-	if (debug) fprintf(stderr,"CHECK:%s",buff);
-}
Index: reautoconf
===================================================================
--- mendexk2.6e.orig/reautoconf
+++ mendexk2.6e/reautoconf
@@ -0,0 +1,7 @@
+#!/bin/sh
+
+set -x
+LANG=C
+rm -rf autom4te.cache/
+
+(cd ../../; ./reautoconf texk/mendexk)
Index: mendex.h
===================================================================
--- mendexk2.6e.orig/mendex.h
+++ mendexk2.6e/mendex.h
@@ -0,0 +1,58 @@
+struct page {
+	char *page;
+	char *enc;
+	char attr[3];
+};
+
+struct index {
+	int num;
+	char words;
+	unsigned char *org[3];
+	unsigned char *dic[3];
+	unsigned char *idx[3];
+	struct page *p;
+	int lnum;
+};
+
+/* convert.c */
+void initkanatable(void);
+int convert(unsigned char *buff1, unsigned char *buff2);
+int pnumconv(char *page, int attr);
+int dicread(char *filename);
+
+/* pageread.c */
+int lastpage(char *filename);
+
+/* sort.c */
+void wsort(struct index *ind, int num);
+void pagesort(struct index *ind, int num);
+int alphanumeric(unsigned char c);
+int alphabet(unsigned char c);
+int numeric(unsigned char c);
+int japanese(unsigned char *buff);
+int chkcontinue(struct page *p, int num);
+
+/* styfile.c */
+void styread(char *filename);
+
+/* fread.c */
+char *mfgets(char *buf, int byte, FILE *fp);
+int idxread(char *filename, int start);
+
+/* fwrite.c */
+int fprintf2   (FILE *fp, const char *format, ...);
+int warn_printf(FILE *fp, const char *format, ...);
+int verb_printf(FILE *fp, const char *format, ...);
+
+struct index;
+void indwrite(char *filename, struct index *ind, int pagenum);
+
+#ifdef fprintf
+#undef fprintf
+#endif
+#define fprintf fprintf2
+
+#ifdef fputs
+#undef fputs
+#endif
+#define fputs   fputs2
Index: sort.c
===================================================================
--- mendexk2.6e.orig/sort.c
+++ mendexk2.6e/sort.c
@@ -2,17 +2,21 @@
 #include <stdlib.h>
 #include <string.h>
 
+#include "mendex.h"
+
 #include "exkana.h"
 #include "exvar.h"
 
 int sym,number,alpha,kana;
 
-wsort(ind,num)
+static int wcomp(const void *p, const void *q);
+static int pcomp(const void *p, const void *q);
+static int ordering(unsigned char *buff);
+
 /*   sort index   */
-struct index *ind;
-int num;
+void wsort(struct index *ind, int num)
 {
-	int i,j,order,wcomp();
+	int i,order;
 
 	for (order=1,i=0;;i++) {
 		switch (character_order[i]) {
@@ -55,11 +59,11 @@
 	qsort(ind,num,sizeof(struct index),wcomp);
 }
 
-int wcomp(index1,index2)
 /*   compare for sorting index   */
-struct index *index1,*index2;
+static int wcomp(const void *p, const void *q)
 {
-	int i,j,k,cc,prechar,pri1,pri2;
+	int i,j,prechar;
+	const struct index *index1 = p, *index2 = q;
 
 	scount++;
 
@@ -142,16 +146,12 @@
 	return 0;
 }
 
-int pagesort(ind,num)
 /*   sort page   */
-struct index *ind;
-int num;
+void pagesort(struct index *ind, int num)
 {
-	int i,j,k,cc;
+	int i,j;
 	struct page *buff;
 
-	int pcomp();
-
 	for (i=0;i<num;i++) {
 		if (ind[i].num==0) continue;
 
@@ -167,12 +167,12 @@
 	}
 }
 
-int pcomp(page1,page2)
 /*   compare for sorting page   */
-struct page *page1,*page2;
+static int pcomp(const void *p, const void *q)
 {
 	int i,j,cc=0,num1,num2;
 	char buff[16];
+	const struct page *page1 = p, *page2 = q;
 
 	scount++;
 
@@ -210,8 +210,7 @@
 	return 0;
 }
 
-int ordering(buff)
-unsigned char *buff;
+static int ordering(unsigned char *buff)
 {
 	if ((*buff)<0x80) {
 		if (alphabet(*buff)) return alpha; 
@@ -224,38 +223,32 @@
 	}
 }
 
-int alphanumeric(c)
-unsigned char c;
+int alphanumeric(unsigned char c)
 {
 	if (((c>='A')&&(c<='Z'))||((c>='a')&&(c<='z'))||((c>='0')&&(c<='9')))
 		return 1;
 	else return 0;
 }
 
-int alphabet(c)
-unsigned char c;
+int alphabet(unsigned char c)
 {
 	if (((c>='A')&&(c<='Z'))||((c>='a')&&(c<='z'))) return 1;
 	else return 0;
 }
 
-int numeric(c)
-unsigned char c;
+int numeric(unsigned char c)
 {
 	if ((c>='0')&&(c<='9')) return 1;
 	else return 0;
 }
 
-int japanese(buff)
-unsigned char *buff;
+int japanese(unsigned char *buff)
 {
 	if (strncmp(buff,HIRATOP,2)>=0) return 1; 
 	else return 0;
 }
 
-int chkcontinue(p,num)
-struct page *p;
-int num;
+int chkcontinue(struct page *p, int num)
 {
 	int i,j,cc=0,num1,num2;
 	char buff[16];
Index: Makefile.am
===================================================================
--- mendexk2.6e.orig/Makefile.am
+++ mendexk2.6e/Makefile.am
@@ -1,38 +1,43 @@
-## Makefile.am for the TeX Live subdirectory texk/makeindexk/
+## Makefile.am for the TeX Live subdirectory texk/mendexk/
 ##
 ## Copyright (C) 2009 Peter Breitenlohner <tex-live@tug.org>
 ## You may freely use, modify and/or distribute this file.
 ##
 ACLOCAL_AMFLAGS = -I ../../m4
 
-INCLUDES = $(KPATHSEA_INCLUDES)
-AM_CPPFLAGS = -DUNIX -DKPATHSEA
+INCLUDES = $(KPATHSEA_INCLUDES) $(PTEXENC_INCLUDES)
+AM_CPPFLAGS = -DKPATHSEA -DKPATHSEA3
 AM_CFLAGS = $(WARNING_CFLAGS)
 
-dist_bin_SCRIPTS = mkindex
 
-bin_PROGRAMS = makeindex
+bin_PROGRAMS = mendex
 
-makeindex_SOURCES = \
-	genind.c \
-	genind.h \
-	mkind.c \
-	mkind.h \
-	qsort.c \
-	scanid.c \
-	scanid.h \
-	scanst.c \
-	scanst.h \
-	sortid.c
+mendex_SOURCES = \
+	convert.c \
+	exkana.h \
+	exvar.h \
+	fread.c	\
+	fwrite.c \
+	kana.h \
+	kp.c \
+	kp.h \
+	ktable.h \
+	main.c \
+	mendex.h \
+	pageread.c \
+	sort.c \
+	styfile.c \
+	var.h
 
-makeindex_DEPENDENCIES = $(KPATHSEA_DEPEND)
+mendex_DEPENDENCIES = $(KPATHSEA_DEPEND) $(PTEXENC_DEPEND)
 
-LDADD = $(KPATHSEA_LIBS)	
+LDADD = $(PTEXENC_LIBS) $(KPATHSEA_LIBS)
 
-## Rebuild libkpathsea
+## Rebuild libkpathsea & libptexenc
 @KPATHSEA_RULE@
+@PTEXENC_RULE@
 
-dist_man1_MANS = makeindex.1 mkindex.1
+dist_man1_MANS = mendex.1
 
-EXTRA_DIST = ACK CONTRIB FILES NOTES PORTING
+EXTRA_DIST = COPYRIGHT COPYRIGHT.jis ChangeLog README
 
Index: exvar.h
===================================================================
--- mendexk2.6e.orig/exvar.h
+++ mendexk2.6e/exvar.h
@@ -1,26 +1,5 @@
-struct page {
-	char *page;
-	char *enc;
-	char attr[3];
-};
-
-struct index {
-	int num;
-	char words;
-	unsigned char *org[3];
-	unsigned char *dic[3];
-	unsigned char *idx[3];
-	struct page *p;
-	int lnum;
-};
-
 extern FILE *efp;
 
-#define Euc 0
-#define Jis 1
-#define Sjis 2
-extern int kanji;
-
 extern int lines,idxcount,acc,reject;
 extern int prange,fsti,lorder,bcomp,force,fpage,gflg,verb,debug;
 extern int warn,scount,pattr[3];
Index: aclocal.m4
===================================================================
--- mendexk2.6e.orig/aclocal.m4
+++ mendexk2.6e/aclocal.m4
@@ -991,6 +991,7 @@
 
 m4_include([../../m4/kpse-common.m4])
 m4_include([../../m4/kpse-kpathsea-flags.m4])
+m4_include([../../m4/kpse-ptexenc-flags.m4])
 m4_include([../../m4/kpse-warnings.m4])
 m4_include([../../m4/libtool.m4])
 m4_include([../../m4/ltoptions.m4])
Index: var.h
===================================================================
--- mendexk2.6e.orig/var.h
+++ mendexk2.6e/var.h
@@ -1,38 +1,9 @@
-struct page {
-	char *page;
-	char *enc;
-	char attr[3];
-};
-
-struct index {
-	int num;
-	char words;
-	unsigned char *org[3];
-	unsigned char *dic[3];
-	unsigned char *idx[3];
-	struct page *p;
-	int lnum;
-};
-
 FILE *efp;
 
-#define Euc 0
-#define Jis 1
-#define Sjis 2
-#ifdef SJIS
-int kanji=Sjis;
-#else
-#ifdef EUC
-int kanji=Euc;
-#else
-int kanji=Jis;
-#endif
-#endif
-
 int lines,idxcount,acc=0,reject=0;
 int prange=1,fsti=0,lorder=0,bcomp=0,force=0,fpage=0,gflg=0,verb=1,debug=0;
 int warn=0,scount=0,pattr[3]={0,0,0};
-static char roman[]={"ivxlcdm"},Roman[]={"IVXLCDM"};
+/* static char roman[]={"ivxlcdm"},Roman[]={"IVXLCDM"}; */
 
 struct index *ind;
 
